---
project:
  sha: v2.13.0
files:
  addon/-private/adapters/build-url-mixin.js:
    name: addon/-private/adapters/build-url-mixin.js
    modules: {}
    classes:
      DS.BuildURLMixin: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/ext/date.js:
    name: addon/-private/ext/date.js
    modules: {}
    classes:
      Ember.Date: 1
    fors: {}
    namespaces:
      Ember: 1
  addon/-private/system/debug/debug-adapter.js:
    name: addon/-private/system/debug/debug-adapter.js
    modules: {}
    classes: {}
    fors: {}
    namespaces: {}
  addon/-private/system/model/errors.js:
    name: addon/-private/system/model/errors.js
    modules: {}
    classes:
      DS.Errors: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/model/internal-model.js:
    name: addon/-private/system/model/internal-model.js
    modules: {}
    classes: {}
    fors: {}
    namespaces: {}
  addon/-private/system/model/model.js:
    name: addon/-private/system/model/model.js
    modules: {}
    classes:
      DS.Model: 1
    fors:
      DS.Model: 1
    namespaces:
      DS: 1
  addon/-private/system/model/states.js:
    name: addon/-private/system/model/states.js
    modules: {}
    classes:
      DS.RootState: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/record-arrays/adapter-populated-record-array.js:
    name: addon/-private/system/record-arrays/adapter-populated-record-array.js
    modules: {}
    classes:
      DS.AdapterPopulatedRecordArray: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/record-arrays/filtered-record-array.js:
    name: addon/-private/system/record-arrays/filtered-record-array.js
    modules: {}
    classes:
      DS.FilteredRecordArray: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/record-arrays/record-array.js:
    name: addon/-private/system/record-arrays/record-array.js
    modules: {}
    classes:
      DS.RecordArray: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/references/belongs-to.js:
    name: addon/-private/system/references/belongs-to.js
    modules: {}
    classes:
      DS.BelongsToReference: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/references/has-many.js:
    name: addon/-private/system/references/has-many.js
    modules: {}
    classes:
      DS.HasManyReference: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/references/record.js:
    name: addon/-private/system/references/record.js
    modules: {}
    classes:
      DS.RecordReference: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/relationships/belongs-to.js:
    name: addon/-private/system/relationships/belongs-to.js
    modules: {}
    classes: {}
    fors:
      DS: 1
    namespaces: {}
  addon/-private/system/relationships/has-many.js:
    name: addon/-private/system/relationships/has-many.js
    modules: {}
    classes: {}
    fors:
      DS: 1
    namespaces: {}
  addon/-private/system/debug.js:
    name: addon/-private/system/debug.js
    modules: {}
    classes: {}
    fors: {}
    namespaces: {}
  addon/-private/system/diff-array.js:
    name: addon/-private/system/diff-array.js
    modules: {}
    classes: {}
    fors:
      DS: 1
    namespaces: {}
  addon/-private/system/identity-map.js:
    name: addon/-private/system/identity-map.js
    modules: {}
    classes:
      IdentityMap: 1
    fors: {}
    namespaces: {}
  addon/-private/system/internal-model-map.js:
    name: addon/-private/system/internal-model-map.js
    modules: {}
    classes:
      InternalModelMap: 1
    fors: {}
    namespaces: {}
  addon/-private/system/many-array.js:
    name: addon/-private/system/many-array.js
    modules: {}
    classes:
      DS.ManyArray: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/model.js:
    name: addon/-private/system/model.js
    modules: {}
    classes: {}
    fors: {}
    namespaces: {}
  addon/-private/system/normalize-model-name.js:
    name: addon/-private/system/normalize-model-name.js
    modules: {}
    classes: {}
    fors:
      DS: 1
    namespaces: {}
  addon/-private/system/promise-proxies.js:
    name: addon/-private/system/promise-proxies.js
    modules: {}
    classes:
      DS.PromiseArray: 1
      DS.PromiseObject: 1
      DS.PromiseManyArray: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/record-array-manager.js:
    name: addon/-private/system/record-array-manager.js
    modules: {}
    classes:
      DS.RecordArrayManager: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/record-arrays.js:
    name: addon/-private/system/record-arrays.js
    modules: {}
    classes: {}
    fors: {}
    namespaces: {}
  addon/-private/system/snapshot-record-array.js:
    name: addon/-private/system/snapshot-record-array.js
    modules: {}
    classes:
      DS.SnapshotRecordArray: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/snapshot.js:
    name: addon/-private/system/snapshot.js
    modules: {}
    classes:
      DS.Snapshot: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/system/store.js:
    name: addon/-private/system/store.js
    modules: {}
    classes:
      DS.Store: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/transforms/boolean.js:
    name: addon/-private/transforms/boolean.js
    modules: {}
    classes:
      DS.BooleanTransform: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/transforms/date.js:
    name: addon/-private/transforms/date.js
    modules: {}
    classes:
      DS.DateTransform: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/transforms/number.js:
    name: addon/-private/transforms/number.js
    modules: {}
    classes:
      DS.NumberTransform: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/transforms/string.js:
    name: addon/-private/transforms/string.js
    modules: {}
    classes:
      DS.StringTransform: 1
    fors: {}
    namespaces:
      DS: 1
  addon/-private/adapters.js:
    name: addon/-private/adapters.js
    modules: {}
    classes: {}
    fors: {}
    namespaces: {}
  addon/-private/core.js:
    name: addon/-private/core.js
    modules: {}
    classes:
      DS: 1
    fors: {}
    namespaces: {}
  addon/-private/serializers.js:
    name: addon/-private/serializers.js
    modules: {}
    classes: {}
    fors: {}
    namespaces: {}
  addon/adapters/errors.js:
    name: addon/adapters/errors.js
    modules: {}
    classes:
      DS.AdapterError: 1
      DS.InvalidError: 1
      DS.TimeoutError: 1
      DS.AbortError: 1
      DS.UnauthorizedError: 1
      DS.ForbiddenError: 1
      DS.NotFoundError: 1
      DS.ConflictError: 1
      DS.ServerError: 1
    fors:
      DS: 1
    namespaces:
      DS: 1
  addon/adapters/json-api.js:
    name: addon/adapters/json-api.js
    modules: {}
    classes:
      DS.JSONAPIAdapter: 1
    fors: {}
    namespaces:
      DS: 1
  addon/adapters/rest.js:
    name: addon/adapters/rest.js
    modules: {}
    classes:
      DS.RESTAdapter: 1
    fors: {}
    namespaces:
      DS: 1
  addon/serializers/embedded-records-mixin.js:
    name: addon/serializers/embedded-records-mixin.js
    modules: {}
    classes:
      DS.EmbeddedRecordsMixin: 1
    fors: {}
    namespaces:
      DS: 1
  addon/serializers/json-api.js:
    name: addon/serializers/json-api.js
    modules: {}
    classes:
      DS.JSONAPISerializer: 1
    fors: {}
    namespaces:
      DS: 1
  addon/serializers/json.js:
    name: addon/serializers/json.js
    modules: {}
    classes:
      DS.JSONSerializer: 1
    fors: {}
    namespaces:
      DS: 1
  addon/serializers/rest.js:
    name: addon/serializers/rest.js
    modules: {}
    classes:
      DS.RESTSerializer: 1
    fors: {}
    namespaces:
      DS: 1
  addon/adapter.js:
    name: addon/adapter.js
    modules: {}
    classes:
      DS.Adapter: 1
    fors: {}
    namespaces:
      DS: 1
  addon/attr.js:
    name: addon/attr.js
    modules: {}
    classes: {}
    fors:
      DS: 1
    namespaces: {}
  addon/index.js:
    name: addon/index.js
    modules:
      ember-data: 1
    classes: {}
    fors: {}
    namespaces: {}
  addon/relationships.js:
    name: addon/relationships.js
    modules: {}
    classes: {}
    fors: {}
    namespaces: {}
  addon/serializer.js:
    name: addon/serializer.js
    modules: {}
    classes:
      DS.Serializer: 1
    fors: {}
    namespaces:
      DS: 1
  addon/transform.js:
    name: addon/transform.js
    modules: {}
    classes:
      DS.Transform: 1
    fors: {}
    namespaces:
      DS: 1
  node_modules/ember-inflector/addon/lib/ext/string.js:
    name: node_modules/ember-inflector/addon/lib/ext/string.js
    modules: {}
    classes: {}
    fors:
      String: 1
      DS.String: 1
    namespaces: {}
  node_modules/ember-inflector/addon/lib/helpers/pluralize.js:
    name: node_modules/ember-inflector/addon/lib/helpers/pluralize.js
    modules: {}
    classes: {}
    fors:
      Ember.HTMLBars.helpers: 1
    namespaces: {}
  node_modules/ember-inflector/addon/lib/helpers/singularize.js:
    name: node_modules/ember-inflector/addon/lib/helpers/singularize.js
    modules: {}
    classes: {}
    fors:
      Ember.HTMLBars.helpers: 1
    namespaces: {}
  node_modules/ember-inflector/addon/lib/system/inflector.js:
    name: node_modules/ember-inflector/addon/lib/system/inflector.js
    modules: {}
    classes:
      Ember.Inflector: 1
    fors: {}
    namespaces:
      Ember: 1
modules:
  ember-data:
    name: ember-data
    submodules: {}
    elements: {}
    classes:
      DS.BuildURLMixin: 1
      Ember.Date: 1
      DS.Errors: 1
      DS.Model: 1
      DS.RootState: 1
      DS.AdapterPopulatedRecordArray: 1
      DS.FilteredRecordArray: 1
      DS.RecordArray: 1
      DS.BelongsToReference: 1
      DS.HasManyReference: 1
      DS.RecordReference: 1
      DS: 1
      IdentityMap: 1
      InternalModelMap: 1
      DS.ManyArray: 1
      DS.PromiseArray: 1
      DS.PromiseObject: 1
      DS.PromiseManyArray: 1
      DS.RecordArrayManager: 1
      DS.SnapshotRecordArray: 1
      DS.Snapshot: 1
      DS.Store: 1
      DS.BooleanTransform: 1
      DS.DateTransform: 1
      DS.NumberTransform: 1
      DS.StringTransform: 1
      DS.AdapterError: 1
      DS.InvalidError: 1
      DS.TimeoutError: 1
      DS.AbortError: 1
      DS.UnauthorizedError: 1
      DS.ForbiddenError: 1
      DS.NotFoundError: 1
      DS.ConflictError: 1
      DS.ServerError: 1
      DS.JSONAPIAdapter: 1
      DS.RESTAdapter: 1
      DS.EmbeddedRecordsMixin: 1
      DS.JSONAPISerializer: 1
      DS.JSONSerializer: 1
      DS.RESTSerializer: 1
      DS.Adapter: 1
      DS.Serializer: 1
      DS.Transform: 1
      DS.String: 1
      DS.Ember.HTMLBars.helpers: 1
      Ember.HTMLBars.helpers: 1
      Ember.Inflector: 1
    fors:
      DS.Model: 1
      DS: 1
      String: 1
      DS.String: 1
      Ember.HTMLBars.helpers: 1
    namespaces:
      Ember: 1
      DS: 1
    tag: main
    file: node_modules/ember-inflector/addon/lib/system/inflector.js
    line: 32
    description: Ember Data
    itemtype: main
classes:
  DS.BuildURLMixin:
    name: DS.BuildURLMixin
    shortname: DS.BuildURLMixin
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for:
    - DS.RESTAdapter
    module: ember-data
    namespace: DS
    file: addon/-private/adapters/build-url-mixin.js
    line: 5
    description: |-
      WARNING: This interface is likely to change in order to accomodate https://github.com/emberjs/rfcs/pull/4
      ## Using BuildURLMixin
      To use url building, include the mixin when extending an adapter, and call `buildURL` where needed.
        The default behaviour is designed for RESTAdapter.
      ### Example
      ```javascript
        export default DS.Adapter.extend(BuildURLMixin, {
          findRecord: function(store, type, id, snapshot) {
            var url = this.buildURL(type.modelName, id, snapshot, 'findRecord');
            return this.ajax(url, 'GET');
          }
        });
        ```
      ### Attributes
      The `host` and `namespace` attributes will be used if defined, and are optional.
  Ember.Date:
    name: Ember.Date
    shortname: Ember.Date
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: Ember
    file: addon/-private/ext/date.js
    line: 9
    description: |-
      Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>

      © 2011 Colin Snover <http://zetafleet.com>

      Released under MIT license.
    static: 1
    deprecated: true
  DS.Errors:
    name: DS.Errors
    shortname: DS.Errors
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/model/errors.js
    line: 15
    description: |-
      Holds validation errors for a given record, organized by attribute names.

      Every `DS.Model` has an `errors` property that is an instance of
      `DS.Errors`. This can be used to display validation error
      messages returned from the server when a `record.save()` rejects.

      For Example, if you had a `User` model that looked like this:

      ```app/models/user.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        username: DS.attr('string'),
        email: DS.attr('string')
      });
      ```
      And you attempted to save a record that did not validate on the backend:

      ```javascript
      let user = store.createRecord('user', {
        username: 'tomster',
        email: 'invalidEmail'
      });
      user.save();
      ```

      Your backend would be expected to return an error response that described
      the problem, so that error messages can be generated on the app.

      API responses will be translated into instances of `DS.Errors` differently,
      depending on the specific combination of adapter and serializer used. You
      may want to check the documentation or the source code of the libraries
      that you are using, to know how they expect errors to be communicated.

      Errors can be displayed to the user by accessing their property name
      to get an array of all the error objects for that property. Each
      error object is a JavaScript object with two keys:

      - `message` A string containing the error message from the backend
      - `attribute` The name of the property associated with this error message

      ```handlebars
      <label>Username: {{input value=username}} </label>
      {{#each model.errors.username as |error|}}
        <div class="error">
          {{error.message}}
        </div>
      {{/each}}

      <label>Email: {{input value=email}} </label>
      {{#each model.errors.email as |error|}}
        <div class="error">
          {{error.message}}
        </div>
      {{/each}}
      ```

      You can also access the special `messages` property on the error
      object to get an array of all the error strings.

      ```handlebars
      {{#each model.errors.messages as |message|}}
        <div class="error">
          {{message}}
        </div>
      {{/each}}
      ```
    extends: Ember.Object
    uses:
    - Ember.Enumerable
    - Ember.Evented
  DS.Model:
    name: DS.Model
    shortname: DS.Model
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/model/model.js
    line: 71
    description: |-
      The model class that all Ember Data records descend from.
        This is the public API of Ember Data models. If you are using Ember Data
        in your application, this is the class you should use.
        If you are working on Ember Data internals, you most likely want to be dealing
        with `InternalModel`
    extends: Ember.Object
    uses:
    - Ember.Evented
  DS.RootState:
    name: DS.RootState
    shortname: DS.RootState
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/model/states.js
    line: 10
    description: |-
      ### State

      Each record has a `currentState` property that explicitly tracks what
      state a record is in at any given time. For instance, if a record is
      newly created and has not yet been sent to the adapter to be saved,
      it would be in the `root.loaded.created.uncommitted` state.  If a
      record has had local modifications made to it that are in the
      process of being saved, the record would be in the
      `root.loaded.updated.inFlight` state. (This state paths will be
      explained in more detail below.)

      Events are sent by the record or its store to the record's
      `currentState` property. How the state reacts to these events is
      dependent on which state it is in. In some states, certain events
      will be invalid and will cause an exception to be raised.

      States are hierarchical and every state is a substate of the
      `RootState`. For example, a record can be in the
      `root.deleted.uncommitted` state, then transition into the
      `root.deleted.inFlight` state. If a child state does not implement
      an event handler, the state manager will attempt to invoke the event
      on all parent states until the root state is reached. The state
      hierarchy of a record is described in terms of a path string. You
      can determine a record's current state by getting the state's
      `stateName` property:

      ```javascript
      record.get('currentState.stateName');
      //=> "root.created.uncommitted"
       ```

      The hierarchy of valid states that ship with ember data looks like
      this:

      ```text
      * root
        * deleted
          * saved
          * uncommitted
          * inFlight
        * empty
        * loaded
          * created
            * uncommitted
            * inFlight
          * saved
          * updated
            * uncommitted
            * inFlight
        * loading
      ```

      The `DS.Model` states are themselves stateless. What that means is
      that, the hierarchical states that each of *those* points to is a
      shared data structure. For performance reasons, instead of each
      record getting its own copy of the hierarchy of states, each record
      points to this global, immutable shared instance. How does a state
      know which record it should be acting on? We pass the record
      instance into the state's event handlers as the first argument.

      The record passed as the first parameter is where you should stash
      state about the record if needed; you should never store data on the state
      object itself.

      ### Events and Flags

      A state may implement zero or more events and flags.

      #### Events

      Events are named functions that are invoked when sent to a record. The
      record will first look for a method with the given name on the
      current state. If no method is found, it will search the current
      state's parent, and then its grandparent, and so on until reaching
      the top of the hierarchy. If the root is reached without an event
      handler being found, an exception will be raised. This can be very
      helpful when debugging new features.

      Here's an example implementation of a state with a `myEvent` event handler:

      ```javascript
      aState: DS.State.create({
        myEvent: function(manager, param) {
          console.log("Received myEvent with", param);
        }
      })
      ```

      To trigger this event:

      ```javascript
      record.send('myEvent', 'foo');
      //=> "Received myEvent with foo"
      ```

      Note that an optional parameter can be sent to a record's `send()` method,
      which will be passed as the second parameter to the event handler.

      Events should transition to a different state if appropriate. This can be
      done by calling the record's `transitionTo()` method with a path to the
      desired state. The state manager will attempt to resolve the state path
      relative to the current state. If no state is found at that path, it will
      attempt to resolve it relative to the current state's parent, and then its
      parent, and so on until the root is reached. For example, imagine a hierarchy
      like this:

          * created
            * uncommitted <-- currentState
            * inFlight
          * updated
            * inFlight

      If we are currently in the `uncommitted` state, calling
      `transitionTo('inFlight')` would transition to the `created.inFlight` state,
      while calling `transitionTo('updated.inFlight')` would transition to
      the `updated.inFlight` state.

      Remember that *only events* should ever cause a state transition. You should
      never call `transitionTo()` from outside a state's event handler. If you are
      tempted to do so, create a new event and send that to the state manager.

      #### Flags

      Flags are Boolean values that can be used to introspect a record's current
      state in a more user-friendly way than examining its state path. For example,
      instead of doing this:

      ```javascript
      var statePath = record.get('stateManager.currentPath');
      if (statePath === 'created.inFlight') {
        doSomething();
      }
      ```

      You can say:

      ```javascript
      if (record.get('isNew') && record.get('isSaving')) {
        doSomething();
      }
      ```

      If your state does not set a value for a given flag, the value will
      be inherited from its parent (or the first place in the state hierarchy
      where it is defined).

      The current set of flags are defined below. If you want to add a new flag,
      in addition to the area below, you will also need to declare it in the
      `DS.Model` class.


       * [isEmpty](DS.Model.html#property_isEmpty)
       * [isLoading](DS.Model.html#property_isLoading)
       * [isLoaded](DS.Model.html#property_isLoaded)
       * [hasDirtyAttributes](DS.Model.html#property_hasDirtyAttributes)
       * [isSaving](DS.Model.html#property_isSaving)
       * [isDeleted](DS.Model.html#property_isDeleted)
       * [isNew](DS.Model.html#property_isNew)
       * [isValid](DS.Model.html#property_isValid)
  DS.AdapterPopulatedRecordArray:
    name: DS.AdapterPopulatedRecordArray
    shortname: DS.AdapterPopulatedRecordArray
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/record-arrays/adapter-populated-record-array.js
    line: 11
    description: |-
      Represents an ordered list of records whose order and membership is
      determined by the adapter. For example, a query sent to the adapter
      may trigger a search on the server, whose results would be loaded
      into an instance of the `AdapterPopulatedRecordArray`.

      ---

      If you want to update the array and get the latest records from the
      adapter, you can invoke [`update()`](#method_update):

      Example

      ```javascript
      // GET /users?isAdmin=true
      var admins = store.query('user', { isAdmin: true });

      admins.then(function() {
        console.log(admins.get("length")); // 42
      });

      // somewhere later in the app code, when new admins have been created
      // in the meantime
      //
      // GET /users?isAdmin=true
      admins.update().then(function() {
        admins.get('isUpdating'); // false
        console.log(admins.get("length")); // 123
      });

      admins.get('isUpdating'); // true
      ```
    extends: DS.RecordArray
  DS.FilteredRecordArray:
    name: DS.FilteredRecordArray
    shortname: DS.FilteredRecordArray
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/record-arrays/filtered-record-array.js
    line: 10
    description: |-
      Represents a list of records whose membership is determined by the
      store. As records are created, loaded, or modified, the store
      evaluates them to determine if they should be part of the record
      array.
    extends: DS.RecordArray
  DS.RecordArray:
    name: DS.RecordArray
    shortname: DS.RecordArray
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/record-arrays/record-array.js
    line: 11
    description: |-
      A record array is an array that contains records of a certain modelName. The record
      array materializes records as needed when they are retrieved for the first
      time. You should not create record arrays yourself. Instead, an instance of
      `DS.RecordArray` or its subclasses will be returned by your application's store
      in response to queries.
    extends: Ember.ArrayProxy
    uses:
    - Ember.Evented
  DS.BelongsToReference:
    name: DS.BelongsToReference
    shortname: DS.BelongsToReference
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/references/belongs-to.js
    line: 9
    description: |-
      A BelongsToReference is a low level API that allows users and
      addon author to perform meta-operations on a belongs-to
      relationship.
    extends: DS.Reference
  DS.HasManyReference:
    name: DS.HasManyReference
    shortname: DS.HasManyReference
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/references/has-many.js
    line: 16
    description: |-
      A HasManyReference is a low level API that allows users and addon
      author to perform meta-operations on a has-many relationship.
  DS.RecordReference:
    name: DS.RecordReference
    shortname: DS.RecordReference
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/references/record.js
    line: 4
    description: |-
      An RecordReference is a low level API that allows users and
      addon author to perform meta-operations on a record.
  DS:
    name: DS
    shortname: DS
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: ''
    file: addon/-private/core.js
    line: 8
    description: All Ember Data classes, methods and functions are defined inside
      of this namespace.
    static: 1
  IdentityMap:
    name: IdentityMap
    shortname: IdentityMap
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: ''
    file: addon/-private/system/identity-map.js
    line: 4
    description: |-
      `IdentityMap` is a custom storage map for records by modelName
      used by `DS.Store`.
    access: private
    tagname: ''
  InternalModelMap:
    name: InternalModelMap
    shortname: InternalModelMap
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: ''
    file: addon/-private/system/internal-model-map.js
    line: 4
    description: |-
      `InternalModelMap` is a custom storage map for internalModels of a given modelName
      used by `IdentityMap`.

      It was extracted from an implicit pojo based "internalModel map" and preserves
      that interface while we work towards a more official API.
    access: private
    tagname: ''
  DS.ManyArray:
    name: DS.ManyArray
    shortname: DS.ManyArray
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/many-array.js
    line: 12
    description: |-
      A `ManyArray` is a `MutableArray` that represents the contents of a has-many
      relationship.

      The `ManyArray` is instantiated lazily the first time the relationship is
      requested.

      ### Inverses

      Often, the relationships in Ember Data applications will have
      an inverse. For example, imagine the following models are
      defined:

      ```app/models/post.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        comments: DS.hasMany('comment')
      });
      ```

      ```app/models/comment.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        post: DS.belongsTo('post')
      });
      ```

      If you created a new instance of `App.Post` and added
      a `App.Comment` record to its `comments` has-many
      relationship, you would expect the comment's `post`
      property to be set to the post that contained
      the has-many.

      We call the record to which a relationship belongs the
      relationship's _owner_.
    extends: Ember.Object
    uses:
    - Ember.MutableArray
    - Ember.Evented
  DS.PromiseArray:
    name: DS.PromiseArray
    shortname: DS.PromiseArray
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/promise-proxies.js
    line: 6
    description: |-
      A `PromiseArray` is an object that acts like both an `Ember.Array`
      and a promise. When the promise is resolved the resulting value
      will be set to the `PromiseArray`'s `content` property. This makes
      it easy to create data bindings with the `PromiseArray` that will be
      updated when the promise resolves.

      For more information see the [Ember.PromiseProxyMixin
      documentation](/api/classes/Ember.PromiseProxyMixin.html).

      Example

      ```javascript
      let promiseArray = DS.PromiseArray.create({
        promise: $.getJSON('/some/remote/data.json')
      });

      promiseArray.get('length'); // 0

      promiseArray.then(function() {
        promiseArray.get('length'); // 100
      });
      ```
    extends: Ember.ArrayProxy
    uses:
    - Ember.PromiseProxyMixin
  DS.PromiseObject:
    name: DS.PromiseObject
    shortname: DS.PromiseObject
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/promise-proxies.js
    line: 37
    description: |-
      A `PromiseObject` is an object that acts like both an `Ember.Object`
      and a promise. When the promise is resolved, then the resulting value
      will be set to the `PromiseObject`'s `content` property. This makes
      it easy to create data bindings with the `PromiseObject` that will
      be updated when the promise resolves.

      For more information see the [Ember.PromiseProxyMixin
      documentation](/api/classes/Ember.PromiseProxyMixin.html).

      Example

      ```javascript
      let promiseObject = DS.PromiseObject.create({
        promise: $.getJSON('/some/remote/data.json')
      });

      promiseObject.get('name'); // null

      promiseObject.then(function() {
        promiseObject.get('name'); // 'Tomster'
      });
      ```
    extends: Ember.ObjectProxy
    uses:
    - Ember.PromiseProxyMixin
  DS.PromiseManyArray:
    name: DS.PromiseManyArray
    shortname: DS.PromiseManyArray
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/promise-proxies.js
    line: 80
    description: |-
      A PromiseManyArray is a PromiseArray that also proxies certain method calls
      to the underlying manyArray.
      Right now we proxy:

        * `reload()`
        * `createRecord()`
        * `on()`
        * `one()`
        * `trigger()`
        * `off()`
        * `has()`
    extends: Ember.ArrayProxy
  DS.RecordArrayManager:
    name: DS.RecordArrayManager
    shortname: DS.RecordArrayManager
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/record-array-manager.js
    line: 63
    access: private
    tagname: ''
  DS.SnapshotRecordArray:
    name: DS.SnapshotRecordArray
    shortname: DS.SnapshotRecordArray
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/snapshot-record-array.js
    line: 5
    access: private
    tagname: ''
    is_constructor: 1
    params:
    - name: snapshots
      description: An array of snapshots
      type: Array
    - name: meta
      description: ''
      type: Object
  DS.Snapshot:
    name: DS.Snapshot
    shortname: DS.Snapshot
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/snapshot.js
    line: 11
    access: private
    tagname: ''
    is_constructor: 1
    params:
    - name: internalModel
      description: The model to create a snapshot from
      type: DS.Model
  DS.Store:
    name: DS.Store
    shortname: DS.Store
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/system/store.js
    line: 134
    description: |-
      The store contains all of the data for records loaded from the server.
      It is also responsible for creating instances of `DS.Model` that wrap
      the individual data for a record, so that they can be bound to in your
      Handlebars templates.

      Define your application's store like this:

      ```app/services/store.js
      import DS from 'ember-data';

      export default DS.Store.extend({
      });
      ```

      Most Ember.js applications will only have a single `DS.Store` that is
      automatically created by their `Ember.Application`.

      You can retrieve models from the store in several ways. To retrieve a record
      for a specific id, use `DS.Store`'s `findRecord()` method:

      ```javascript
      store.findRecord('person', 123).then(function (person) {
      });
      ```

      By default, the store will talk to your backend using a standard
      REST mechanism. You can customize how the store talks to your
      backend by specifying a custom adapter:

      ```app/adapters/application.js
      import DS from 'ember-data';

      export default DS.Adapter.extend({
      });
      ```

      You can learn more about writing a custom adapter by reading the `DS.Adapter`
      documentation.

      ### Store createRecord() vs. push() vs. pushPayload()

      The store provides multiple ways to create new record objects. They have
      some subtle differences in their use which are detailed below:

      [createRecord](#method_createRecord) is used for creating new
      records on the client side. This will return a new record in the
      `created.uncommitted` state. In order to persist this record to the
      backend you will need to call `record.save()`.

      [push](#method_push) is used to notify Ember Data's store of new or
      updated records that exist in the backend. This will return a record
      in the `loaded.saved` state. The primary use-case for `store#push` is
      to notify Ember Data about record updates (full or partial) that happen
      outside of the normal adapter methods (for example
      [SSE](http://dev.w3.org/html5/eventsource/) or [Web
      Sockets](http://www.w3.org/TR/2009/WD-websockets-20091222/)).

      [pushPayload](#method_pushPayload) is a convenience wrapper for
      `store#push` that will deserialize payloads if the
      Serializer implements a `pushPayload` method.

      Note: When creating a new record using any of the above methods
      Ember Data will update `DS.RecordArray`s such as those returned by
      `store#peekAll()`, `store#findAll()` or `store#filter()`. This means any
      data bindings or computed properties that depend on the RecordArray
      will automatically be synced to include the new or updated record
      values.
    extends: Ember.Service
  DS.BooleanTransform:
    name: DS.BooleanTransform
    shortname: DS.BooleanTransform
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/transforms/boolean.js
    line: 6
    description: |-
      The `DS.BooleanTransform` class is used to serialize and deserialize
      boolean attributes on Ember Data record objects. This transform is
      used when `boolean` is passed as the type parameter to the
      [DS.attr](../../data#method_attr) function.

      Usage

      ```app/models/user.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        isAdmin: DS.attr('boolean'),
        name: DS.attr('string'),
        email: DS.attr('string')
      });
      ```

      By default the boolean transform only allows for values of `true` or
      `false`. You can opt into allowing `null` values for
      boolean attributes via `DS.attr('boolean', { allowNull: true })`

      ```app/models/user.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        email: DS.attr('string'),
        username: DS.attr('string'),
        wantsWeeklyEmail: DS.attr('boolean', { allowNull: true })
      });
      ```
    extends: DS.Transform
  DS.DateTransform:
    name: DS.DateTransform
    shortname: DS.DateTransform
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/transforms/date.js
    line: 3
    description: |-
      The `DS.DateTransform` class is used to serialize and deserialize
      date attributes on Ember Data record objects. This transform is used
      when `date` is passed as the type parameter to the
      [DS.attr](../../data#method_attr) function. It uses the [`ISO 8601`](https://en.wikipedia.org/wiki/ISO_8601)
      standard.

      ```app/models/score.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        value: DS.attr('number'),
        player: DS.belongsTo('player'),
        date: DS.attr('date')
      });
      ```
    extends: DS.Transform
  DS.NumberTransform:
    name: DS.NumberTransform
    shortname: DS.NumberTransform
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/transforms/number.js
    line: 10
    description: |-
      The `DS.NumberTransform` class is used to serialize and deserialize
      numeric attributes on Ember Data record objects. This transform is
      used when `number` is passed as the type parameter to the
      [DS.attr](../../data#method_attr) function.

      Usage

      ```app/models/score.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        value: DS.attr('number'),
        player: DS.belongsTo('player'),
        date: DS.attr('date')
      });
      ```
    extends: DS.Transform
  DS.StringTransform:
    name: DS.StringTransform
    shortname: DS.StringTransform
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/-private/transforms/string.js
    line: 6
    description: |-
      The `DS.StringTransform` class is used to serialize and deserialize
      string attributes on Ember Data record objects. This transform is
      used when `string` is passed as the type parameter to the
      [DS.attr](../../data#method_attr) function.

      Usage

      ```app/models/user.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        isAdmin: DS.attr('boolean'),
        name: DS.attr('string'),
        email: DS.attr('string')
      });
      ```
    extends: DS.Transform
  DS.AdapterError:
    name: DS.AdapterError
    shortname: DS.AdapterError
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/errors.js
    line: 11
    description: |-
      A `DS.AdapterError` is used by an adapter to signal that an error occurred
      during a request to an external API. It indicates a generic error, and
      subclasses are used to indicate specific error states. The following
      subclasses are provided:

      - `DS.InvalidError`
      - `DS.TimeoutError`
      - `DS.AbortError`
      - `DS.UnauthorizedError`
      - `DS.ForbiddenError`
      - `DS.NotFoundError`
      - `DS.ConflictError`
      - `DS.ServerError`

      To create a custom error to signal a specific error state in communicating
      with an external API, extend the `DS.AdapterError`. For example if the
      external API exclusively used HTTP `503 Service Unavailable` to indicate
      it was closed for maintenance:

      ```app/adapters/maintenance-error.js
      import DS from 'ember-data';

      export default DS.AdapterError.extend({ message: "Down for maintenance." });
      ```

      This error would then be returned by an adapter's `handleResponse` method:

      ```app/adapters/application.js
      import DS from 'ember-data';
      import MaintenanceError from './maintenance-error';

      export default DS.JSONAPIAdapter.extend({
        handleResponse(status) {
          if (503 === status) {
            return new MaintenanceError();
          }

          return this._super(...arguments);
        }
      });
      ```

      And can then be detected in an application and used to send the user to an
      `under-maintenance` route:

      ```app/routes/application.js
      import Ember from 'ember';
      import MaintenanceError from '../adapters/maintenance-error';

      export default Ember.Route.extend({
        actions: {
          error(error, transition) {
            if (error instanceof MaintenanceError) {
              this.transitionTo('under-maintenance');
              return;
            }

            // ...other error handling logic
          }
        }
      });
      ```
  DS.InvalidError:
    name: DS.InvalidError
    shortname: DS.InvalidError
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/errors.js
    line: 121
    description: |-
      A `DS.InvalidError` is used by an adapter to signal the external API
      was unable to process a request because the content was not
      semantically correct or meaningful per the API. Usually this means a
      record failed some form of server side validation. When a promise
      from an adapter is rejected with a `DS.InvalidError` the record will
      transition to the `invalid` state and the errors will be set to the
      `errors` property on the record.

      For Ember Data to correctly map errors to their corresponding
      properties on the model, Ember Data expects each error to be
      a valid json-api error object with a `source/pointer` that matches
      the property name. For example if you had a Post model that
      looked like this.

      ```app/models/post.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        title: DS.attr('string'),
        content: DS.attr('string')
      });
      ```

      To show an error from the server related to the `title` and
      `content` properties your adapter could return a promise that
      rejects with a `DS.InvalidError` object that looks like this:

      ```app/adapters/post.js
      import Ember from 'ember';
      import DS from 'ember-data';

      export default DS.RESTAdapter.extend({
        updateRecord() {
          // Fictional adapter that always rejects
          return Ember.RSVP.reject(new DS.InvalidError([
            {
              detail: 'Must be unique',
              source: { pointer: '/data/attributes/title' }
            },
            {
              detail: 'Must not be blank',
              source: { pointer: '/data/attributes/content'}
            }
          ]));
        }
      });
      ```

      Your backend may use different property names for your records the
      store will attempt extract and normalize the errors using the
      serializer's `extractErrors` method before the errors get added to
      the the model. As a result, it is safe for the `InvalidError` to
      wrap the error payload unaltered.
  DS.TimeoutError:
    name: DS.TimeoutError
    shortname: DS.TimeoutError
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/errors.js
    line: 182
    description: |-
      A `DS.TimeoutError` is used by an adapter to signal that a request
      to the external API has timed out. I.e. no response was received from
      the external API within an allowed time period.

      An example use case would be to warn the user to check their internet
      connection if an adapter operation has timed out:

      ```app/routes/application.js
      import Ember from 'ember';
      import DS from 'ember-data';

      const { TimeoutError } = DS;

      export default Ember.Route.extend({
        actions: {
          error(error, transition) {
            if (error instanceof TimeoutError) {
              // alert the user
              alert('Are you still connected to the internet?');
              return;
            }

            // ...other error handling logic
          }
        }
      });
      ```
  DS.AbortError:
    name: DS.AbortError
    shortname: DS.AbortError
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/errors.js
    line: 217
    description: |-
      A `DS.AbortError` is used by an adapter to signal that a request to
      the external API was aborted. For example, this can occur if the user
      navigates away from the current page after a request to the external API
      has been initiated but before a response has been received.
  DS.UnauthorizedError:
    name: DS.UnauthorizedError
    shortname: DS.UnauthorizedError
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/errors.js
    line: 229
    description: |-
      A `DS.UnauthorizedError` equates to a HTTP `401 Unauthorized` response
      status. It is used by an adapter to signal that a request to the external
      API was rejected because authorization is required and has failed or has not
      yet been provided.

      An example use case would be to redirect the user to a log in route if a
      request is unauthorized:

      ```app/routes/application.js
      import Ember from 'ember';
      import DS from 'ember-data';

      const { UnauthorizedError } = DS;

      export default Ember.Route.extend({
        actions: {
          error(error, transition) {
            if (error instanceof UnauthorizedError) {
              // go to the sign in route
              this.transitionTo('login');
              return;
            }

            // ...other error handling logic
          }
        }
      });
      ```
  DS.ForbiddenError:
    name: DS.ForbiddenError
    shortname: DS.ForbiddenError
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/errors.js
    line: 265
    description: |-
      A `DS.ForbiddenError` equates to a HTTP `403 Forbidden` response status.
      It is used by an adapter to signal that a request to the external API was
      valid but the server is refusing to respond to it. If authorization was
      provided and is valid, then the authenticated user does not have the
      necessary permissions for the request.
  DS.NotFoundError:
    name: DS.NotFoundError
    shortname: DS.NotFoundError
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/errors.js
    line: 278
    description: |-
      A `DS.NotFoundError` equates to a HTTP `404 Not Found` response status.
      It is used by an adapter to signal that a request to the external API
      was rejected because the resource could not be found on the API.

      An example use case would be to detect if the user has entered a route
      for a specific model that does not exist. For example:

      ```app/routes/post.js
      import Ember from 'ember';
      import DS from 'ember-data';

      const { NotFoundError } = DS;

      export default Ember.Route.extend({
        model(params) {
          return this.get('store').findRecord('post', params.post_id);
        },

        actions: {
          error(error, transition) {
            if (error instanceof NotFoundError) {
              // redirect to a list of all posts instead
              this.transitionTo('posts');
            } else {
              // otherwise let the error bubble
              return true;
            }
          }
        }
      });
      ```
  DS.ConflictError:
    name: DS.ConflictError
    shortname: DS.ConflictError
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/errors.js
    line: 317
    description: |-
      A `DS.ConflictError` equates to a HTTP `409 Conflict` response status.
      It is used by an adapter to indicate that the request could not be processed
      because of a conflict in the request. An example scenario would be when
      creating a record with a client generated id but that id is already known
      to the external API.
  DS.ServerError:
    name: DS.ServerError
    shortname: DS.ServerError
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/errors.js
    line: 330
    description: |-
      A `DS.ServerError` equates to a HTTP `500 Internal Server Error` response
      status. It is used by the adapter to indicate that a request has failed
      because of an error in the external API.
  DS.JSONAPIAdapter:
    name: DS.JSONAPIAdapter
    shortname: DS.JSONAPIAdapter
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/json-api.js
    line: 11
    description: |-
      The `JSONAPIAdapter` is the default adapter used by Ember Data. It
      is responsible for transforming the store's requests into HTTP
      requests that follow the [JSON API](http://jsonapi.org/format/)
      format.

      ## JSON API Conventions

      The JSONAPIAdapter uses JSON API conventions for building the url
      for a record and selecting the HTTP verb to use with a request. The
      actions you can take on a record map onto the following URLs in the
      JSON API adapter:

      <table>
      <tr>
        <th>
          Action
        </th>
        <th>
          HTTP Verb
        </th>
        <th>
          URL
        </th>
      </tr>
      <tr>
        <th>
          `store.findRecord('post', 123)`
        </th>
        <td>
          GET
        </td>
        <td>
          /posts/123
        </td>
      </tr>
      <tr>
        <th>
          `store.findAll('post')`
        </th>
        <td>
          GET
        </td>
        <td>
          /posts
        </td>
      </tr>
      <tr>
        <th>
          Update `postRecord.save()`
        </th>
        <td>
          PATCH
        </td>
        <td>
          /posts/123
        </td>
      </tr>
      <tr>
        <th>
          Create `store.createRecord('post').save()`
        </th>
        <td>
          POST
        </td>
        <td>
          /posts
        </td>
      </tr>
      <tr>
        <th>
          Delete `postRecord.destroyRecord()`
        </th>
        <td>
          DELETE
        </td>
        <td>
          /posts/123
        </td>
      </tr>
      </table>

      ## Success and failure

      The JSONAPIAdapter will consider a success any response with a
      status code of the 2xx family ("Success"), as well as 304 ("Not
      Modified"). Any other status code will be considered a failure.

      On success, the request promise will be resolved with the full
      response payload.

      Failed responses with status code 422 ("Unprocessable Entity") will
      be considered "invalid". The response will be discarded, except for
      the `errors` key. The request promise will be rejected with a
      `DS.InvalidError`. This error object will encapsulate the saved
      `errors` value.

      Any other status codes will be treated as an adapter error. The
      request promise will be rejected, similarly to the invalid case,
      but with an instance of `DS.AdapterError` instead.

      ### Endpoint path customization

      Endpoint paths can be prefixed with a `namespace` by setting the
      namespace property on the adapter:

      ```app/adapters/application.js
      import DS from 'ember-data';

      export default DS.JSONAPIAdapter.extend({
        namespace: 'api/1'
      });
      ```
      Requests for the `person` model would now target `/api/1/people/1`.

      ### Host customization

      An adapter can target other hosts by setting the `host` property.

      ```app/adapters/application.js
      import DS from 'ember-data';

      export default DS.JSONAPIAdapter.extend({
        host: 'https://api.example.com'
      });
      ```

      Requests for the `person` model would now target
      `https://api.example.com/people/1`.
    since: 1.13.0
    is_constructor: 1
    extends: DS.RESTAdapter
  DS.RESTAdapter:
    name: DS.RESTAdapter
    shortname: DS.RESTAdapter
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapters/rest.js
    line: 31
    description: |-
      The REST adapter allows your store to communicate with an HTTP server by
      transmitting JSON via XHR. Most Ember.js apps that consume a JSON API
      should use the REST adapter.

      This adapter is designed around the idea that the JSON exchanged with
      the server should be conventional.

      ## Success and failure

      The REST adapter will consider a success any response with a status code
      of the 2xx family ("Success"), as well as 304 ("Not Modified"). Any other
      status code will be considered a failure.

      On success, the request promise will be resolved with the full response
      payload.

      Failed responses with status code 422 ("Unprocessable Entity") will be
      considered "invalid". The response will be discarded, except for the
      `errors` key. The request promise will be rejected with a `DS.InvalidError`.
      This error object will encapsulate the saved `errors` value.

      Any other status codes will be treated as an "adapter error". The request
      promise will be rejected, similarly to the "invalid" case, but with
      an instance of `DS.AdapterError` instead.

      ## JSON Structure

      The REST adapter expects the JSON returned from your server to follow
      these conventions.

      ### Object Root

      The JSON payload should be an object that contains the record inside a
      root property. For example, in response to a `GET` request for
      `/posts/1`, the JSON should look like this:

      ```js
      {
        "posts": {
          "id": 1,
          "title": "I'm Running to Reform the W3C's Tag",
          "author": "Yehuda Katz"
        }
      }
      ```

      Similarly, in response to a `GET` request for `/posts`, the JSON should
      look like this:

      ```js
      {
        "posts": [
          {
            "id": 1,
            "title": "I'm Running to Reform the W3C's Tag",
            "author": "Yehuda Katz"
          },
          {
            "id": 2,
            "title": "Rails is omakase",
            "author": "D2H"
          }
        ]
      }
      ```

      Note that the object root can be pluralized for both a single-object response
      and an array response: the REST adapter is not strict on this. Further, if the
      HTTP server responds to a `GET` request to `/posts/1` (e.g. the response to a
      `findRecord` query) with more than one object in the array, Ember Data will
      only display the object with the matching ID.

      ### Conventional Names

      Attribute names in your JSON payload should be the camelCased versions of
      the attributes in your Ember.js models.

      For example, if you have a `Person` model:

      ```app/models/person.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        firstName: DS.attr('string'),
        lastName: DS.attr('string'),
        occupation: DS.attr('string')
      });
      ```

      The JSON returned should look like this:

      ```js
      {
        "people": {
          "id": 5,
          "firstName": "Zaphod",
          "lastName": "Beeblebrox",
          "occupation": "President"
        }
      }
      ```

      #### Relationships

      Relationships are usually represented by ids to the record in the
      relationship. The related records can then be sideloaded in the
      response under a key for the type.

      ```js
      {
        "posts": {
          "id": 5,
          "title": "I'm Running to Reform the W3C's Tag",
          "author": "Yehuda Katz",
          "comments": [1, 2]
        },
        "comments": [{
          "id": 1,
          "author": "User 1",
          "message": "First!",
        }, {
          "id": 2,
          "author": "User 2",
          "message": "Good Luck!",
        }]
      }
      ```

      If the records in the relationship are not known when the response
      is serialized its also possible to represent the relationship as a
      url using the `links` key in the response. Ember Data will fetch
      this url to resolve the relationship when it is accessed for the
      first time.

      ```js
      {
        "posts": {
          "id": 5,
          "title": "I'm Running to Reform the W3C's Tag",
          "author": "Yehuda Katz",
          "links": {
            "comments": "/posts/5/comments"
          }
        }
      }
      ```

      ### Errors

      If a response is considered a failure, the JSON payload is expected to include
      a top-level key `errors`, detailing any specific issues. For example:

      ```js
      {
        "errors": {
          "msg": "Something went wrong"
        }
      }
      ```

      This adapter does not make any assumptions as to the format of the `errors`
      object. It will simply be passed along as is, wrapped in an instance
      of `DS.InvalidError` or `DS.AdapterError`. The serializer can interpret it
      afterwards.

      ## Customization

      ### Endpoint path customization

      Endpoint paths can be prefixed with a `namespace` by setting the namespace
      property on the adapter:

      ```app/adapters/application.js
      import DS from 'ember-data';

      export default DS.RESTAdapter.extend({
        namespace: 'api/1'
      });
      ```
      Requests for the `Person` model would now target `/api/1/people/1`.

      ### Host customization

      An adapter can target other hosts by setting the `host` property.

      ```app/adapters/application.js
      import DS from 'ember-data';

      export default DS.RESTAdapter.extend({
        host: 'https://api.example.com'
      });
      ```

      ### Headers customization

      Some APIs require HTTP headers, e.g. to provide an API key. Arbitrary
      headers can be set as key/value pairs on the `RESTAdapter`'s `headers`
      object and Ember Data will send them along with each ajax request.


      ```app/adapters/application.js
      import DS from 'ember-data';

      export default DS.RESTAdapter.extend({
        headers: {
          'API_KEY': 'secret key',
          'ANOTHER_HEADER': 'Some header value'
        }
      });
      ```

      `headers` can also be used as a computed property to support dynamic
      headers. In the example below, the `session` object has been
      injected into an adapter by Ember's container.

      ```app/adapters/application.js
      import DS from 'ember-data';

      export default DS.RESTAdapter.extend({
        headers: Ember.computed('session.authToken', function() {
          return {
            'API_KEY': this.get('session.authToken'),
            'ANOTHER_HEADER': 'Some header value'
          };
        })
      });
      ```

      In some cases, your dynamic headers may require data from some
      object outside of Ember's observer system (for example
      `document.cookie`). You can use the
      [volatile](/api/classes/Ember.ComputedProperty.html#method_volatile)
      function to set the property into a non-cached mode causing the headers to
      be recomputed with every request.

      ```app/adapters/application.js
      import DS from 'ember-data';

      export default DS.RESTAdapter.extend({
        headers: Ember.computed(function() {
          return {
            'API_KEY': Ember.get(document.cookie.match(/apiKey\=([^;]*)/), '1'),
            'ANOTHER_HEADER': 'Some header value'
          };
        }).volatile()
      });
      ```
    is_constructor: 1
    extends: DS.Adapter
    uses:
    - DS.BuildURLMixin
  DS.EmbeddedRecordsMixin:
    name: DS.EmbeddedRecordsMixin
    shortname: DS.EmbeddedRecordsMixin
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/serializers/embedded-records-mixin.js
    line: 8
    description: |-
      ## Using Embedded Records

      `DS.EmbeddedRecordsMixin` supports serializing embedded records.

      To set up embedded records, include the mixin when extending a serializer,
      then define and configure embedded (model) relationships.

      Note that embedded records will serialize with the serializer for their model instead of the serializer in which they are defined.

      Below is an example of a per-type serializer (`post` type).

      ```app/serializers/post.js
      import DS from 'ember-data';

      export default DS.RESTSerializer.extend(DS.EmbeddedRecordsMixin, {
        attrs: {
          author: { embedded: 'always' },
          comments: { serialize: 'ids' }
        }
      });
      ```
      Note that this use of `{ embedded: 'always' }` is unrelated to
      the `{ embedded: 'always' }` that is defined as an option on `DS.attr` as part of
      defining a model while working with the `ActiveModelSerializer`.  Nevertheless,
      using `{ embedded: 'always' }` as an option to `DS.attr` is not a valid way to setup
      embedded records.

      The `attrs` option for a resource `{ embedded: 'always' }` is shorthand for:

      ```js
      {
        serialize: 'records',
        deserialize: 'records'
      }
      ```

      ### Configuring Attrs

      A resource's `attrs` option may be set to use `ids`, `records` or false for the
      `serialize`  and `deserialize` settings.

      The `attrs` property can be set on the `ApplicationSerializer` or a per-type
      serializer.

      In the case where embedded JSON is expected while extracting a payload (reading)
      the setting is `deserialize: 'records'`, there is no need to use `ids` when
      extracting as that is the default behavior without this mixin if you are using
      the vanilla `EmbeddedRecordsMixin`. Likewise, to embed JSON in the payload while
      serializing `serialize: 'records'` is the setting to use. There is an option of
      not embedding JSON in the serialized payload by using `serialize: 'ids'`. If you
      do not want the relationship sent at all, you can use `serialize: false`.


      ### EmbeddedRecordsMixin defaults
      If you do not overwrite `attrs` for a specific relationship, the `EmbeddedRecordsMixin`
      will behave in the following way:

      BelongsTo: `{ serialize: 'id', deserialize: 'id' }`
      HasMany:   `{ serialize: false, deserialize: 'ids' }`

      ### Model Relationships

      Embedded records must have a model defined to be extracted and serialized. Note that
      when defining any relationships on your model such as `belongsTo` and `hasMany`, you
      should not both specify `async: true` and also indicate through the serializer's
      `attrs` attribute that the related model should be embedded for deserialization.
      If a model is declared embedded for deserialization (`embedded: 'always'` or `deserialize: 'records'`),
      then do not use `async: true`.

      To successfully extract and serialize embedded records the model relationships
      must be setup correcty. See the
      [defining relationships](/guides/models/defining-models/#toc_defining-relationships)
      section of the **Defining Models** guide page.

      Records without an `id` property are not considered embedded records, model
      instances must have an `id` property to be used with Ember Data.

      ### Example JSON payloads, Models and Serializers

      **When customizing a serializer it is important to grok what the customizations
      are. Please read the docs for the methods this mixin provides, in case you need
      to modify it to fit your specific needs.**

      For example review the docs for each method of this mixin:
      * [normalize](/api/data/classes/DS.EmbeddedRecordsMixin.html#method_normalize)
      * [serializeBelongsTo](/api/data/classes/DS.EmbeddedRecordsMixin.html#method_serializeBelongsTo)
      * [serializeHasMany](/api/data/classes/DS.EmbeddedRecordsMixin.html#method_serializeHasMany)
  DS.JSONAPISerializer:
    name: DS.JSONAPISerializer
    shortname: DS.JSONAPISerializer
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/serializers/json-api.js
    line: 14
    description: |-
      Ember Data 2.0 Serializer:

      In Ember Data a Serializer is used to serialize and deserialize
      records when they are transferred in and out of an external source.
      This process involves normalizing property names, transforming
      attribute values and serializing relationships.

      `JSONAPISerializer` supports the http://jsonapi.org/ spec and is the
      serializer recommended by Ember Data.

      This serializer normalizes a JSON API payload that looks like:

      ```app/models/player.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        name: DS.attr('string'),
        skill: DS.attr('string'),
        gamesPlayed: DS.attr('number'),
        club: DS.belongsTo('club')
      });
      ```

      ```app/models/club.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        name: DS.attr('string'),
        location: DS.attr('string'),
        players: DS.hasMany('player')
      });
      ```

      ```js
        {
          "data": [
            {
              "attributes": {
                "name": "Benfica",
                "location": "Portugal"
              },
              "id": "1",
              "relationships": {
                "players": {
                  "data": [
                    {
                      "id": "3",
                      "type": "players"
                    }
                  ]
                }
              },
              "type": "clubs"
            }
          ],
          "included": [
            {
              "attributes": {
                "name": "Eusebio Silva Ferreira",
                "skill": "Rocket shot",
                "games-played": 431
              },
              "id": "3",
              "relationships": {
                "club": {
                  "data": {
                    "id": "1",
                    "type": "clubs"
                  }
                }
              },
              "type": "players"
            }
          ]
        }
      ```

      to the format that the Ember Data store expects.

      ### Customizing meta

      Since a JSON API Document can have meta defined in multiple locations you can
      use the specific serializer hooks if you need to customize the meta.

      One scenario would be to camelCase the meta keys of your payload. The example
      below shows how this could be done using `normalizeArrayResponse` and
      `extractRelationship`.

      ```app/serializers/application.js
      export default JSONAPISerializer.extend({
        normalizeArrayResponse(store, primaryModelClass, payload, id, requestType) {
          let normalizedDocument = this._super(...arguments);

          // Customize document meta
          normalizedDocument.meta = camelCaseKeys(normalizedDocument.meta);

          return normalizedDocument;
        },

        extractRelationship(relationshipHash) {
          let normalizedRelationship = this._super(...arguments);

          // Customize relationship meta
          normalizedRelationship.meta = camelCaseKeys(normalizedRelationship.meta);

          return normalizedRelationship;
        }
      });
      ```
    since: 1.13.0
    extends: DS.JSONSerializer
  DS.JSONSerializer:
    name: DS.JSONSerializer
    shortname: DS.JSONSerializer
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/serializers/json.js
    line: 19
    description: |-
      Ember Data 2.0 Serializer:

      In Ember Data a Serializer is used to serialize and deserialize
      records when they are transferred in and out of an external source.
      This process involves normalizing property names, transforming
      attribute values and serializing relationships.

      By default, Ember Data uses and recommends the `JSONAPISerializer`.

      `JSONSerializer` is useful for simpler or legacy backends that may
      not support the http://jsonapi.org/ spec.

      For example, given the following `User` model and JSON payload:

      ```app/models/user.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        friends: DS.hasMany('user'),
        house: DS.belongsTo('location'),

        name: DS.attr('string')
      });
      ```

      ```js
      {
        id: 1,
        name: 'Sebastian',
        friends: [3, 4],
        links: {
          house: '/houses/lefkada'
        }
      }
      ```

      `JSONSerializer` will normalize the JSON payload to the JSON API format that the
      Ember Data store expects.

      You can customize how JSONSerializer processes its payload by passing options in
      the `attrs` hash or by subclassing the `JSONSerializer` and overriding hooks:

        - To customize how a single record is normalized, use the `normalize` hook.
        - To customize how `JSONSerializer` normalizes the whole server response, use the
          `normalizeResponse` hook.
        - To customize how `JSONSerializer` normalizes a specific response from the server,
          use one of the many specific `normalizeResponse` hooks.
        - To customize how `JSONSerializer` normalizes your id, attributes or relationships,
          use the `extractId`, `extractAttributes` and `extractRelationships` hooks.

      The `JSONSerializer` normalization process follows these steps:

        - `normalizeResponse` - entry method to the serializer.
        - `normalizeCreateRecordResponse` - a `normalizeResponse` for a specific operation is called.
        - `normalizeSingleResponse`|`normalizeArrayResponse` - for methods like `createRecord` we expect
          a single record back, while for methods like `findAll` we expect multiple methods back.
        - `normalize` - `normalizeArray` iterates and calls `normalize` for each of its records while `normalizeSingle`
          calls it once. This is the method you most likely want to subclass.
        - `extractId` | `extractAttributes` | `extractRelationships` - `normalize` delegates to these methods to
          turn the record payload into the JSON API format.
    extends: DS.Serializer
  DS.RESTSerializer:
    name: DS.RESTSerializer
    shortname: DS.RESTSerializer
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/serializers/rest.js
    line: 16
    description: |-
      Normally, applications will use the `RESTSerializer` by implementing
      the `normalize` method.

      This allows you to do whatever kind of munging you need, and is
      especially useful if your server is inconsistent and you need to
      do munging differently for many different kinds of responses.

      See the `normalize` documentation for more information.

      ## Across the Board Normalization

      There are also a number of hooks that you might find useful to define
      across-the-board rules for your payload. These rules will be useful
      if your server is consistent, or if you're building an adapter for
      an infrastructure service, like Firebase, and want to encode service
      conventions.

      For example, if all of your keys are underscored and all-caps, but
      otherwise consistent with the names you use in your models, you
      can implement across-the-board rules for how to convert an attribute
      name in your model to a key in your JSON.

      ```app/serializers/application.js
      import DS from 'ember-data';

      export default DS.RESTSerializer.extend({
        keyForAttribute(attr, method) {
          return Ember.String.underscore(attr).toUpperCase();
        }
      });
      ```

      You can also implement `keyForRelationship`, which takes the name
      of the relationship as the first parameter, the kind of
      relationship (`hasMany` or `belongsTo`) as the second parameter, and
      the method (`serialize` or `deserialize`) as the third parameter.
    extends: DS.JSONSerializer
  DS.Adapter:
    name: DS.Adapter
    shortname: DS.Adapter
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/adapter.js
    line: 7
    description: |-
      An adapter is an object that receives requests from a store and
      translates them into the appropriate action to take against your
      persistence layer. The persistence layer is usually an HTTP API, but
      may be anything, such as the browser's local storage. Typically the
      adapter is not invoked directly instead its functionality is accessed
      through the `store`.

      ### Creating an Adapter

      Create a new subclass of `DS.Adapter` in the `app/adapters` folder:

      ```app/adapters/application.js
      import DS from 'ember-data';

      export default DS.Adapter.extend({
        // ...your code here
      });
      ```

      Model-specific adapters can be created by putting your adapter
      class in an `app/adapters/` + `model-name` + `.js` file of the application.

      ```app/adapters/post.js
      import DS from 'ember-data';

      export default DS.Adapter.extend({
        // ...Post-specific adapter code goes here
      });
      ```

      `DS.Adapter` is an abstract base class that you should override in your
      application to customize it for your backend. The minimum set of methods
      that you should implement is:

        * `findRecord()`
        * `createRecord()`
        * `updateRecord()`
        * `deleteRecord()`
        * `findAll()`
        * `query()`

      To improve the network performance of your application, you can optimize
      your adapter by overriding these lower-level methods:

        * `findMany()`


      For an example implementation, see `DS.RESTAdapter`, the
      included REST adapter.
    extends: Ember.Object
  DS.Serializer:
    name: DS.Serializer
    shortname: DS.Serializer
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/serializer.js
    line: 7
    description: |-
      `DS.Serializer` is an abstract base class that you should override in your
      application to customize it for your backend. The minimum set of methods
      that you should implement is:

        * `normalizeResponse()`
        * `serialize()`

      And you can optionally override the following methods:

        * `normalize()`

      For an example implementation, see
      [DS.JSONSerializer](DS.JSONSerializer.html), the included JSON serializer.
    extends: Ember.Object
  DS.Transform:
    name: DS.Transform
    shortname: DS.Transform
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
    file: addon/transform.js
    line: 3
    description: |-
      The `DS.Transform` class is used to serialize and deserialize model
      attributes when they are saved or loaded from an
      adapter. Subclassing `DS.Transform` is useful for creating custom
      attributes. All subclasses of `DS.Transform` must implement a
      `serialize` and a `deserialize` method.

      Example

      ```app/transforms/temperature.js
      import DS from 'ember-data';

      // Converts centigrade in the JSON to fahrenheit in the app
      export default DS.Transform.extend({
        deserialize(serialized, options) {
          return (serialized *  1.8) + 32;
        },

        serialize(deserialized, options) {
          return (deserialized - 32) / 1.8;
        }
      });
      ```

      The options passed into the `DS.attr` function when the attribute is
      declared on the model is also available in the transform.

      ```app/models/post.js
      export default DS.Model.extend({
        title: DS.attr('string'),
        markdown: DS.attr('markdown', {
          markdown: {
            gfm: false,
            sanitize: true
          }
        })
      });
      ```

      ```app/transforms/markdown.js
      export default DS.Transform.extend({
        serialize(deserialized, options) {
          return deserialized.raw;
        },

        deserialize(serialized, options) {
          var markdownOptions = options.markdown || {};

          return marked(serialized, markdownOptions);
        }
      });
      ```

      Usage

      ```app/models/requirement.js
      import DS from 'ember-data';

      export default DS.Model.extend({
        name: DS.attr('string'),
        temperature: DS.attr('temperature')
      });
      ```
  DS.String:
    name: DS.String
    shortname: String
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
  DS.Ember.HTMLBars.helpers:
    name: DS.Ember.HTMLBars.helpers
    shortname: Ember.HTMLBars.helpers
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: DS
  Ember.HTMLBars.helpers:
    name: Ember.HTMLBars.helpers
    shortname: Ember.HTMLBars.helpers
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: ''
  Ember.Inflector:
    name: Ember.Inflector
    shortname: Ember.Inflector
    classitems: []
    plugins: []
    extensions: []
    plugin_for: []
    extension_for: []
    module: ember-data
    namespace: Ember
    file: node_modules/ember-inflector/addon/lib/system/inflector.js
    line: 32
    description: |-
      Inflector.Ember provides a mechanism for supplying inflection rules for your
      application. Ember includes a default set of inflection rules, and provides an
      API for providing additional rules.

      Examples:

      Creating an inflector with no rules.

      ```js
      var inflector = new Ember.Inflector();
      ```

      Creating an inflector with the default ember ruleset.

      ```js
      var inflector = new Ember.Inflector(Ember.Inflector.defaultRules);

      inflector.pluralize('cow'); //=> 'kine'
      inflector.singularize('kine'); //=> 'cow'
      ```

      Creating an inflector and adding rules later.

      ```javascript
      var inflector = Ember.Inflector.inflector;

      inflector.pluralize('advice'); // => 'advices'
      inflector.uncountable('advice');
      inflector.pluralize('advice'); // => 'advice'

      inflector.pluralize('formula'); // => 'formulas'
      inflector.irregular('formula', 'formulae');
      inflector.pluralize('formula'); // => 'formulae'

      // you would not need to add these as they are the default rules
      inflector.plural(/$/, 's');
      inflector.singular(/s$/i, '');
      ```

      Creating an inflector with a nondefault ruleset.

      ```javascript
      var rules = {
        plurals:  [
          [ /$/, 's' ]
        ],
        singular: [
          [ /\s$/, '' ]
        ],
        irregularPairs: [
          [ 'cow', 'kine' ]
        ],
        uncountable: [ 'fish' ]
      };

      var inflector = new Ember.Inflector(rules);
      ```
elements: {}
classitems:
- file: addon/-private/adapters/build-url-mixin.js
  line: 33
  description: |-
    Builds a URL for a given type and optional ID.

    By default, it pluralizes the type's name (for example, 'post'
    becomes 'posts' and 'person' becomes 'people'). To override the
    pluralization see [pathForType](#method_pathForType).

    If an ID is specified, it adds the ID to the path generated
    for the type, separated by a `/`.

    When called by RESTAdapter.findMany() the `id` and `snapshot` parameters
    will be arrays of ids and snapshots.
  itemtype: method
  name: buildURL
  params:
  - name: modelName
    description: ''
    type: String
  - name: id
    description: single id or array of ids or query
    type: "(String|Array|Object)"
  - name: snapshot
    description: single snapshot or array of snapshots
    type: "(DS.Snapshot|Array)"
  - name: requestType
    description: ''
    type: String
  - name: query
    description: object of query parameters to send for query requests.
    type: Object
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 81
  itemtype: method
  name: _buildURL
  access: private
  tagname: ''
  params:
  - name: modelName
    description: ''
    type: String
  - name: id
    description: ''
    type: String
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 110
  description: |-
    Builds a URL for a `store.findRecord(type, id)` call.

    Example:

    ```app/adapters/user.js
    import DS from 'ember-data';

    export default DS.JSONAPIAdapter.extend({
      urlForFindRecord(id, modelName, snapshot) {
        let baseUrl = this.buildURL();
        return `${baseUrl}/users/${snapshot.adapterOptions.user_id}/playlists/${id}`;
      }
    });
    ```
  itemtype: method
  name: urlForFindRecord
  params:
  - name: id
    description: ''
    type: String
  - name: modelName
    description: ''
    type: String
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 137
  description: |-
    Builds a URL for a `store.findAll(type)` call.

    Example:

    ```app/adapters/comment.js
    import DS from 'ember-data';

    export default DS.JSONAPIAdapter.extend({
      urlForFindAll(modelName, snapshot) {
        return 'data/comments.json';
      }
    });
    ```
  itemtype: method
  name: urlForFindAll
  params:
  - name: modelName
    description: ''
    type: String
  - name: snapshot
    description: ''
    type: DS.SnapshotRecordArray
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 161
  description: |-
    Builds a URL for a `store.query(type, query)` call.

    Example:

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      host: 'https://api.github.com',
      urlForQuery (query, modelName) {
        switch(modelName) {
          case 'repo':
            return `https://api.github.com/orgs/${query.orgId}/repos`;
          default:
            return this._super(...arguments);
        }
      }
    });
    ```
  itemtype: method
  name: urlForQuery
  params:
  - name: query
    description: ''
    type: Object
  - name: modelName
    description: ''
    type: String
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 191
  description: |-
    Builds a URL for a `store.queryRecord(type, query)` call.

    Example:

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      urlForQueryRecord({ slug }, modelName) {
        let baseUrl = this.buildURL();
        return `${baseUrl}/${encodeURIComponent(slug)}`;
      }
    });
    ```
  itemtype: method
  name: urlForQueryRecord
  params:
  - name: query
    description: ''
    type: Object
  - name: modelName
    description: ''
    type: String
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 216
  description: |-
    Builds a URL for coalesceing multiple `store.findRecord(type, id)
    records into 1 request when the adapter's `coalesceFindRequests`
    property is true.

    Example:

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      urlForFindMany(ids, modelName) {
        let baseUrl = this.buildURL();
        return `${baseUrl}/coalesce`;
      }
    });
    ```
  itemtype: method
  name: urlForFindMany
  params:
  - name: ids
    description: ''
    type: Array
  - name: modelName
    description: ''
    type: String
  - name: snapshots
    description: ''
    type: Array
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 244
  description: |-
    Builds a URL for fetching a async hasMany relationship when a url
    is not provided by the server.

    Example:

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.JSONAPIAdapter.extend({
      urlForFindHasMany(id, modelName, snapshot) {
        let baseUrl = this.buildURL(id, modelName);
        return `${baseUrl}/relationships`;
      }
    });
    ```
  itemtype: method
  name: urlForFindHasMany
  params:
  - name: id
    description: ''
    type: String
  - name: modelName
    description: ''
    type: String
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 271
  description: |-
    Builds a URL for fetching a async belongsTo relationship when a url
    is not provided by the server.

    Example:

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.JSONAPIAdapter.extend({
      urlForFindBelongsTo(id, modelName, snapshot) {
        let baseUrl = this.buildURL(id, modelName);
        return `${baseUrl}/relationships`;
      }
    });
    ```
  itemtype: method
  name: urlForFindBelongsTo
  params:
  - name: id
    description: ''
    type: String
  - name: modelName
    description: ''
    type: String
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 298
  description: |-
    Builds a URL for a `record.save()` call when the record was created
    locally using `store.createRecord()`.

    Example:

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      urlForCreateRecord(modelName, snapshot) {
        return this._super(...arguments) + '/new';
      }
    });
    ```
  itemtype: method
  name: urlForCreateRecord
  params:
  - name: modelName
    description: ''
    type: String
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 323
  description: |-
    Builds a URL for a `record.save()` call when the record has been update locally.

    Example:

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      urlForUpdateRecord(id, modelName, snapshot) {
        return `/${id}/feed?access_token=${snapshot.adapterOptions.token}`;
      }
    });
    ```
  itemtype: method
  name: urlForUpdateRecord
  params:
  - name: id
    description: ''
    type: String
  - name: modelName
    description: ''
    type: String
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 348
  description: |-
    Builds a URL for a `record.save()` call when the record has been deleted locally.

    Example:

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      urlForDeleteRecord(id, modelName, snapshot) {
        return this._super(...arguments) + '/destroy';
      }
    });
    ```
  itemtype: method
  name: urlForDeleteRecord
  params:
  - name: id
    description: ''
    type: String
  - name: modelName
    description: ''
    type: String
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: url
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 373
  itemtype: method
  name: urlPrefix
  access: private
  tagname: ''
  params:
  - name: path
    description: ''
    type: String
  - name: parentURL
    description: ''
    type: String
  return:
    description: urlPrefix
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/adapters/build-url-mixin.js
  line: 410
  description: |-
    Determines the pathname for a given type.

    By default, it pluralizes the type's name (for example,
    'post' becomes 'posts' and 'person' becomes 'people').

    ### Pathname customization

    For example if you have an object LineItem with an
    endpoint of "/line_items/".

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      pathForType: function(modelName) {
        var decamelized = Ember.String.decamelize(modelName);
        return Ember.String.pluralize(decamelized);
      }
    });
    ```
  itemtype: method
  name: pathForType
  params:
  - name: modelName
    description: ''
    type: String
  return:
    description: path
    type: String
  class: DS.BuildURLMixin
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 91
  description: Register with target handler
  itemtype: method
  name: registerHandlers
  params:
  - name: target
    description: ''
    type: Object
  - name: becameInvalid
    description: ''
    type: Function
  - name: becameValid
    description: ''
    type: Function
  deprecated: true
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 111
  description: Register with target handler
  itemtype: method
  name: _registerHandlers
  access: private
  tagname: ''
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 123
  itemtype: property
  name: errorsByAttributeName
  type: "{Ember.MapWithDefault}"
  access: private
  tagname: ''
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 136
  description: |-
    Returns errors for a given attribute

    ```javascript
    let user = store.createRecord('user', {
      username: 'tomster',
      email: 'invalidEmail'
    });
    user.save().catch(function(){
      user.get('errors').errorsFor('email'); // returns:
      // [{attribute: "email", message: "Doesn't look like a valid email."}]
    });
    ```
  itemtype: method
  name: errorsFor
  params:
  - name: attribute
    description: ''
    type: String
  return:
    description: ''
    type: Array
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 158
  description: |-
    An array containing all of the error messages for this
    record. This is useful for displaying all errors to the user.

    ```handlebars
    {{#each model.errors.messages as |message|}}
      <div class="error">
        {{message}}
      </div>
    {{/each}}
    ```
  itemtype: property
  name: messages
  type: "{Array}"
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 175
  itemtype: property
  name: content
  type: "{Array}"
  access: private
  tagname: ''
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 184
  itemtype: method
  name: unknownProperty
  access: private
  tagname: ''
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 194
  description: Total number of errors.
  itemtype: property
  name: length
  type: "{Number}"
  readonly: ''
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 202
  itemtype: property
  name: isEmpty
  type: "{Boolean}"
  readonly: ''
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 209
  description: |-
    Adds error messages to a given attribute and sends
    `becameInvalid` event to the record.

    Example:

    ```javascript
    if (!user.get('username') {
      user.get('errors').add('username', 'This field is required');
    }
    ```
  itemtype: method
  name: add
  params:
  - name: attribute
    description: ''
    type: String
  - name: messages
    description: ''
    type: "(Array|String)"
  deprecated: true
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 241
  description: Adds error messages to a given attribute without sending event.
  itemtype: method
  name: _add
  access: private
  tagname: ''
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 255
  itemtype: method
  name: _findOrCreateMessages
  access: private
  tagname: ''
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 280
  description: |-
    Removes all error messages from the given attribute and sends
    `becameValid` event to the record if there no more errors left.

    Example:

    ```app/models/user.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      email: DS.attr('string'),
      twoFactorAuth: DS.attr('boolean'),
      phone: DS.attr('string')
    });
    ```

    ```app/routes/user/edit.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      actions: {
        save: function(user) {
           if (!user.get('twoFactorAuth')) {
             user.get('errors').remove('phone');
           }
           user.save();
         }
      }
    });
    ```
  itemtype: method
  name: remove
  params:
  - name: attribute
    description: ''
    type: String
  deprecated: true
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 329
  description: Removes all error messages from the given attribute without sending
    event.
  itemtype: method
  name: _remove
  access: private
  tagname: ''
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 345
  description: |-
    Removes all error messages and sends `becameValid` event
    to the record.

    Example:

    ```app/routes/user/edit.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      actions: {
        retrySave: function(user) {
           user.get('errors').clear();
           user.save();
         }
      }
    });
    ```
  itemtype: method
  name: clear
  deprecated: true
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 379
  description: |-
    Removes all error messages.
    to the record.
  itemtype: method
  name: _clear
  access: private
  tagname: ''
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/errors.js
  line: 405
  description: |-
    Checks if there is error messages for the given attribute.

    ```app/routes/user/edit.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      actions: {
        save: function(user) {
           if (user.get('errors').has('email')) {
             return alert('Please update your email before attempting to save.');
           }
           user.save();
         }
      }
    });
    ```
  itemtype: method
  name: has
  params:
  - name: attribute
    description: ''
    type: String
  return:
    description: true if there some errors on given attribute
    type: Boolean
  class: DS.Errors
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/internal-model.js
  line: 410
  description: |-
    Computes the set of internal models reachable from `this` across exactly one
    relationship.
  return:
    description: |-
      An array containing the internal models that `this` belongs
      to or has many.
    type: Array
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/internal-model.js
  line: 432
  description: |-
    Computes the set of internal models reachable from this internal model.

    Reachability is determined over the relationship graph (ie a graph where
    nodes are internal models and edges are belongs to or has many
    relationships).
  return:
    description: |-
      An array including `this` and all internal models reachable
      from `this`.
    type: Array
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/internal-model.js
  line: 465
  description: |-
    Unload the record for this internal model. This will cause the record to be
    destroyed and freed up for garbage collection. It will also do a check
    for cleaning up internal models.

    This check is performed by first computing the set of related internal
    models. If all records in this set are unloaded, then the entire set is
    destroyed. Otherwise, nothing in the set is destroyed.

    This means that this internal model will be freed up for garbage collection
    once all models that refer to it via some relationship are also unloaded.
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 91
  description: |-
    If this property is `true` the record is in the `empty`
    state. Empty is the first state all records enter after they have
    been created. Most records created by the store will quickly
    transition to the `loading` state if data needs to be fetched from
    the server or the `created` state if the record is created on the
    client. A record can also enter the empty state if the adapter is
    unable to locate the record.
  itemtype: property
  name: isEmpty
  type: "{Boolean}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 105
  description: |-
    If this property is `true` the record is in the `loading` state. A
    record enters this state when the store asks the adapter for its
    data. It remains in this state until the adapter provides the
    requested data.
  itemtype: property
  name: isLoading
  type: "{Boolean}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 116
  description: |-
    If this property is `true` the record is in the `loaded` state. A
    record enters this state when its data is populated. Most of a
    record's lifecycle is spent inside substates of the `loaded`
    state.

    Example

    ```javascript
    let record = store.createRecord('model');
    record.get('isLoaded'); // true

    store.findRecord('model', 1).then(function(model) {
      model.get('isLoaded'); // true
    });
    ```
  itemtype: property
  name: isLoaded
  type: "{Boolean}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 138
  description: |-
    If this property is `true` the record is in the `dirty` state. The
    record has local changes that have not yet been saved by the
    adapter. This includes records that have been created (but not yet
    saved) or deleted.

    Example

    ```javascript
    let record = store.createRecord('model');
    record.get('hasDirtyAttributes'); // true

    store.findRecord('model', 1).then(function(model) {
      model.get('hasDirtyAttributes'); // false
      model.set('foo', 'some value');
      model.get('hasDirtyAttributes'); // true
    });
    ```
  since: 1.13.0
  itemtype: property
  name: hasDirtyAttributes
  type: "{Boolean}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 165
  description: |-
    If this property is `true` the record is in the `saving` state. A
    record enters the saving state when `save` is called, but the
    adapter has not yet acknowledged that the changes have been
    persisted to the backend.

    Example

    ```javascript
    let record = store.createRecord('model');
    record.get('isSaving'); // false
    let promise = record.save();
    record.get('isSaving'); // true
    promise.then(function() {
      record.get('isSaving'); // false
    });
    ```
  itemtype: property
  name: isSaving
  type: "{Boolean}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 188
  description: |-
    If this property is `true` the record is in the `deleted` state
    and has been marked for deletion. When `isDeleted` is true and
    `hasDirtyAttributes` is true, the record is deleted locally but the deletion
    was not yet persisted. When `isSaving` is true, the change is
    in-flight. When both `hasDirtyAttributes` and `isSaving` are false, the
    change has persisted.

    Example

    ```javascript
    let record = store.createRecord('model');
    record.get('isDeleted');    // false
    record.deleteRecord();

    // Locally deleted
    record.get('isDeleted');           // true
    record.get('hasDirtyAttributes');  // true
    record.get('isSaving');            // false

    // Persisting the deletion
    let promise = record.save();
    record.get('isDeleted');    // true
    record.get('isSaving');     // true

    // Deletion Persisted
    promise.then(function() {
      record.get('isDeleted');          // true
      record.get('isSaving');           // false
      record.get('hasDirtyAttributes'); // false
    });
    ```
  itemtype: property
  name: isDeleted
  type: "{Boolean}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 226
  description: |-
    If this property is `true` the record is in the `new` state. A
    record will be in the `new` state when it has been created on the
    client and the adapter has not yet report that it was successfully
    saved.

    Example

    ```javascript
    let record = store.createRecord('model');
    record.get('isNew'); // true

    record.save().then(function(model) {
      model.get('isNew'); // false
    });
    ```
  itemtype: property
  name: isNew
  type: "{Boolean}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 248
  description: |-
    If this property is `true` the record is in the `valid` state.

    A record will be in the `valid` state when the adapter did not report any
    server-side validation failures.
  itemtype: property
  name: isValid
  type: "{Boolean}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 259
  description: |-
    If the record is in the dirty state this property will report what
    kind of change has caused it to move into the dirty
    state. Possible values are:

    - `created` The record has been created by the client and not yet saved to the adapter.
    - `updated` The record has been updated by the client and not yet saved to the adapter.
    - `deleted` The record has been deleted by the client and not yet saved to the adapter.

    Example

    ```javascript
    let record = store.createRecord('model');
    record.get('dirtyType'); // 'created'
    ```
  itemtype: property
  name: dirtyType
  type: "{String}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 281
  description: |-
    If `true` the adapter reported that it was unable to save local
    changes to the backend for any reason other than a server-side
    validation error.

    Example

    ```javascript
    record.get('isError'); // false
    record.set('foo', 'valid value');
    record.save().then(null, function() {
      record.get('isError'); // true
    });
    ```
  itemtype: property
  name: isError
  type: "{Boolean}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 302
  description: |-
    If `true` the store is attempting to reload the record from the adapter.

    Example

    ```javascript
    record.get('isReloading'); // false
    record.reload();
    record.get('isReloading'); // true
    ```
  itemtype: property
  name: isReloading
  type: "{Boolean}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 319
  description: |-
    All ember models have an id property. This is an identifier
    managed by an external source. These are always coerced to be
    strings before being used internally. Note when declaring the
    attributes for a model it is an error to declare an id
    attribute.

    ```javascript
    let record = store.createRecord('model');
    record.get('id'); // null

    store.findRecord('model', 1).then(function(model) {
      model.get('id'); // '1'
    });
    ```
  itemtype: property
  name: id
  type: "{String}"
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 340
  itemtype: property
  name: currentState
  access: private
  tagname: ''
  type: "{Object}"
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 347
  description: |-
    When the record is in the `invalid` state this object will contain
    any errors returned by the adapter. When present the errors hash
    contains keys corresponding to the invalid property names
    and values which are arrays of Javascript objects with two keys:

    - `message` A string containing the error message from the backend
    - `attribute` The name of the property associated with this error message

    ```javascript
    record.get('errors.length'); // 0
    record.set('foo', 'invalid value');
    record.save().catch(function() {
      record.get('errors').get('foo');
      // [{message: 'foo should be a number.', attribute: 'foo'}]
    });
    ```

    The `errors` property us useful for displaying error messages to
    the user.

    ```handlebars
    <label>Username: {{input value=username}} </label>
    {{#each model.errors.username as |error|}}
      <div class="error">
        {{error.message}}
      </div>
    {{/each}}
    <label>Email: {{input value=email}} </label>
    {{#each model.errors.email as |error|}}
      <div class="error">
        {{error.message}}
      </div>
    {{/each}}
    ```


    You can also access the special `messages` property on the error
    object to get an array of all the error strings.

    ```handlebars
    {{#each model.errors.messages as |message|}}
      <div class="error">
        {{message}}
      </div>
    {{/each}}
    ```
  itemtype: property
  name: errors
  type: "{DS.Errors}"
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 411
  description: |-
    This property holds the `DS.AdapterError` object with which
    last adapter operation was rejected.
  itemtype: property
  name: adapterError
  type: "{DS.AdapterError}"
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 420
  description: |-
    Create a JSON representation of the record, using the serialization
    strategy of the store's adapter.

       `serialize` takes an optional hash as a parameter, currently
    supported options are:

       - `includeId`: `true` if the record's ID should be included in the
      JSON representation.
  itemtype: method
  name: serialize
  params:
  - name: options
    description: ''
    type: Object
  return:
    description: an object whose values are primitive JSON values only
    type: Object
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 438
  description: |-
    Use [DS.JSONSerializer](DS.JSONSerializer.html) to
    get the JSON representation of a record.

    `toJSON` takes an optional hash as a parameter, currently
    supported options are:

    - `includeId`: `true` if the record's ID should be included in the
      JSON representation.
  itemtype: method
  name: toJSON
  params:
  - name: options
    description: ''
    type: Object
  return:
    description: A JSON representation of the object.
    type: Object
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 460
  description: |-
    Fired when the record is ready to be interacted with,
    that is either loaded from the server or created locally.
  itemtype: event
  name: ready
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 468
  description: Fired when the record is loaded from the server.
  itemtype: event
  name: didLoad
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 475
  description: Fired when the record is updated.
  itemtype: event
  name: didUpdate
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 482
  description: Fired when a new record is commited to the server.
  itemtype: event
  name: didCreate
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 489
  description: Fired when the record is deleted.
  itemtype: event
  name: didDelete
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 496
  description: Fired when the record becomes invalid.
  itemtype: event
  name: becameInvalid
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 503
  description: Fired when the record enters the error state.
  itemtype: event
  name: becameError
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 510
  description: Fired when the record is rolled back.
  itemtype: event
  name: rolledBack
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 518
  itemtype: method
  name: send
  access: private
  tagname: ''
  params:
  - name: name
    description: ''
    type: String
  - name: context
    description: ''
    type: Object
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 528
  itemtype: method
  name: transitionTo
  access: private
  tagname: ''
  params:
  - name: name
    description: ''
    type: String
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 538
  description: |-
    Marks the record as deleted but does not save it. You must call
    `save` afterwards if you want to persist it. You might use this
    method if you want to allow the user to still `rollbackAttributes()`
    after a delete was made.

    Example

    ```app/routes/model/delete.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      actions: {
        softDelete: function() {
          this.controller.get('model').deleteRecord();
        },
        confirm: function() {
          this.controller.get('model').save();
        },
        undo: function() {
          this.controller.get('model').rollbackAttributes();
        }
      }
    });
    ```
  itemtype: method
  name: deleteRecord
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 570
  description: |-
    Same as `deleteRecord`, but saves the record immediately.

    Example

    ```app/routes/model/delete.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      actions: {
        delete: function() {
          let controller = this.controller;
          controller.get('model').destroyRecord().then(function() {
            controller.transitionToRoute('model.index');
          });
        }
      }
    });
    ```

    If you pass an object on the `adapterOptions` property of the options
    argument it will be passed to your adapter via the snapshot

    ```js
    record.destroyRecord({ adapterOptions: { subscribe: false } });
    ```

    ```app/adapters/post.js
    import MyCustomAdapter from './custom-adapter';

    export default MyCustomAdapter.extend({
      deleteRecord: function(store, type, snapshot) {
        if (snapshot.adapterOptions.subscribe) {
          // ...
        }
        // ...
      }
    });
    ```
  itemtype: method
  name: destroyRecord
  params:
  - name: options
    description: ''
    type: Object
  return:
    description: |-
      a promise that will be resolved when the adapter returns
      successfully or rejected if the adapter returns with an error.
    type: Promise
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 620
  description: Unloads the record from the store. This will cause the record to be
    destroyed and freed up for garbage collection.
  itemtype: method
  name: unloadRecord
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 630
  itemtype: method
  name: _notifyProperties
  access: private
  tagname: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 644
  description: |-
    Returns an object, whose keys are changed properties, and value is
    an [oldProp, newProp] array.

    The array represents the diff of the canonical state with the local state
    of the model. Note: if the model is created locally, the canonical state is
    empty since the adapter hasn't acknowledged the attributes yet:

    Example

    ```app/models/mascot.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      name: DS.attr('string'),
      isAdmin: DS.attr('boolean', {
        defaultValue: false
      })
    });
    ```

    ```javascript
    let mascot = store.createRecord('mascot');

    mascot.changedAttributes(); // {}

    mascot.set('name', 'Tomster');
    mascot.changedAttributes(); // { name: [undefined, 'Tomster'] }

    mascot.set('isAdmin', true);
    mascot.changedAttributes(); // { isAdmin: [undefined, true], name: [undefined, 'Tomster'] }

    mascot.save().then(function() {
      mascot.changedAttributes(); // {}

      mascot.set('isAdmin', false);
      mascot.changedAttributes(); // { isAdmin: [true, false] }
    });
    ```
  itemtype: method
  name: changedAttributes
  return:
    description: |-
      an object, whose keys are changed properties,
        and value is an [oldProp, newProp] array.
    type: Object
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 694
  itemtype: method
  name: adapterDidDirty
  access: private
  tagname: |-
    adapterDidDirty: function() {
    this.send('becomeDirty');
    this.updateRecordArraysLater();
      },
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 710
  description: |-
    If the model `hasDirtyAttributes` this function will discard any unsaved
    changes. If the model `isNew` it will be removed from the store.

    Example

    ```javascript
    record.get('name'); // 'Untitled Document'
    record.set('name', 'Doc 1');
    record.get('name'); // 'Doc 1'
    record.rollbackAttributes();
    record.get('name'); // 'Untitled Document'
    ```
  since: 1.13.0
  itemtype: method
  name: rollbackAttributes
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 743
  description: |-
    Save the record and persist any changes to the record to an
    external source via the adapter.

    Example

    ```javascript
    record.set('name', 'Tomster');
    record.save().then(function() {
      // Success callback
    }, function() {
      // Error callback
    });
    ```

       If you pass an object on the `adapterOptions` property of the options
       argument it will be passed to you adapter via the snapshot

    ```js
    record.save({ adapterOptions: { subscribe: false } });
    ```

    ```app/adapters/post.js
    import MyCustomAdapter from './custom-adapter';

    export default MyCustomAdapter.extend({
      updateRecord: function(store, type, snapshot) {
        if (snapshot.adapterOptions.subscribe) {
          // ...
        }
        // ...
      }
    });
    ```
  itemtype: method
  name: save
  params:
  - name: options
    description: ''
    type: Object
  return:
    description: |-
      a promise that will be resolved when the adapter returns
      successfully or rejected if the adapter returns with an error.
    type: Promise
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 789
  description: |-
    Reload the record from the adapter.

    This will only work if the record has already finished loading.

    Example

    ```app/routes/model/view.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      actions: {
        reload: function() {
          this.controller.get('model').reload().then(function(model) {
            // do something with the reloaded model
          });
        }
      }
    });
    ```
  itemtype: method
  name: reload
  return:
    description: |-
      a promise that will be resolved with the record when the
      adapter returns successfully or rejected if the adapter returns
      with an error.
    type: Promise
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 822
  description: |-
    Override the default event firing from Ember.Evented to
    also call methods with the given name.
  itemtype: method
  name: trigger
  access: private
  tagname: ''
  params:
  - name: name
    description: ''
    type: String
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 854
  description: |-
    Get the reference for the specified belongsTo relationship.

    Example

    ```app/models/blog.js
    export default DS.Model.extend({
      user: DS.belongsTo({ async: true })
    });
    ```

    ```javascript
    let blog = store.push({
      data: {
        type: 'blog',
        id: 1,
        relationships: {
          user: {
            data: { type: 'user', id: 1 }
          }
        }
      }
    });
    let userRef = blog.belongsTo('user');

    // check if the user relationship is loaded
    let isLoaded = userRef.value() !== null;

    // get the record of the reference (null if not yet available)
    let user = userRef.value();

    // get the identifier of the reference
    if (userRef.remoteType() === "id") {
      let id = userRef.id();
    } else if (userRef.remoteType() === "link") {
      let link = userRef.link();
    }

    // load user (via store.findRecord or store.findBelongsTo)
    userRef.load().then(...)

    // or trigger a reload
    userRef.reload().then(...)

    // provide data for reference
    userRef.push({
      type: 'user',
      id: 1,
      attributes: {
        username: "@user"
      }
    }).then(function(user) {
      userRef.value() === user;
    });
    ```
  itemtype: method
  name: belongsTo
  params:
  - name: name
    description: of the relationship
    type: String
  since: 2.5.0
  return:
    description: reference for this relationship
    type: BelongsToReference
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 919
  description: |-
    Get the reference for the specified hasMany relationship.

    Example

    ```javascript
    // models/blog.js
    export default DS.Model.extend({
      comments: DS.hasMany({ async: true })
    });

    let blog = store.push({
      data: {
        type: 'blog',
        id: 1,
        relationships: {
          comments: {
            data: [
              { type: 'comment', id: 1 },
              { type: 'comment', id: 2 }
            ]
          }
        }
      }
    });
    let commentsRef = blog.hasMany('comments');

    // check if the comments are loaded already
    let isLoaded = commentsRef.value() !== null;

    // get the records of the reference (null if not yet available)
    let comments = commentsRef.value();

    // get the identifier of the reference
    if (commentsRef.remoteType() === "ids") {
      let ids = commentsRef.ids();
    } else if (commentsRef.remoteType() === "link") {
      let link = commentsRef.link();
    }

    // load comments (via store.findMany or store.findHasMany)
    commentsRef.load().then(...)

    // or trigger a reload
    commentsRef.reload().then(...)

    // provide data for reference
    commentsRef.push([{ type: 'comment', id: 1 }, { type: 'comment', id: 2 }]).then(function(comments) {
      commentsRef.value() === comments;
    });
    ```
  itemtype: method
  name: hasMany
  params:
  - name: name
    description: of the relationship
    type: String
  since: 2.5.0
  return:
    description: reference for this relationship
    type: HasManyReference
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 984
  description: |-
    Provides info about the model for debugging purposes
    by grouping the properties into more semantic groups.

    Meant to be used by debugging tools such as the Chrome Ember Extension.

    - Groups all attributes in "Attributes" group.
    - Groups all belongsTo relationships in "Belongs To" group.
    - Groups all hasMany relationships in "Has Many" group.
    - Groups all flags in "Flags" group.
    - Flags relationship CPs as expensive properties.
  itemtype: method
  name: _debugInfo
  access: private
  tagname: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1050
  description: |-
    This Ember.js hook allows an object to be notified when a property
    is defined.

    In this case, we use it to be notified when an Ember Data user defines a
    belongs-to relationship. In that case, we need to set up observers for
    each one, allowing us to track relationship changes and automatically
    reflect changes in the inverse has-many array.

    This hook passes the class being set up, as well as the key and value
    being defined. So, for example, when the user does this:

    ```javascript
    DS.Model.extend({
     parent: DS.belongsTo('user')
      });
    ```

    This hook would be called with "parent" as the key and the computed
    property returned by `DS.belongsTo` as the value.
  itemtype: method
  name: didDefineProperty
  params:
  - name: proto
    description: ''
    type: Object
  - name: key
    description: ''
    type: String
  - name: value
    description: ''
    type: Ember.ComputedProperty
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1089
  description: |-
    Given a callback, iterates over each of the relationships in the model,
    invoking the callback with the name of each relationship and its relationship
    descriptor.


    The callback method you provide should have the following signature (all
    parameters are optional):

    ```javascript
    function(name, descriptor);
    ```

    - `name` the name of the current property in the iteration
    - `descriptor` the meta object that describes this relationship

    The relationship descriptor argument is an object with the following properties.

    - **key** <span class="type">String</span> the name of this relationship on the Model
    - **kind** <span class="type">String</span> "hasMany" or "belongsTo"
    - **options** <span class="type">Object</span> the original options hash passed when the relationship was declared
    - **parentType** <span class="type">DS.Model</span> the type of the Model that owns this relationship
    - **type** <span class="type">String</span> the type name of the related Model

    Note that in addition to a callback, you can also pass an optional target
    object that will be set as `this` on the context.

    Example

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
     serialize: function(record, options) {
       let json = {};

       record.eachRelationship(function(name, descriptor) {
         if (descriptor.kind === 'hasMany') {
           let serializedHasManyName = name.toUpperCase() + '_IDS';
           json[serializedHasManyName] = record.get(name).mapBy('id');
         }
       });

       return json;
     }
      });
    ```
  itemtype: method
  name: eachRelationship
  params:
  - name: callback
    description: the callback to invoke
    type: Function
  - name: binding
    description: the value to which the callback's `this` should be bound
    type: Any
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1167
  itemtype: property
  name: data
  access: private
  tagname: ''
  type: "{Object}"
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1193
  description: |-
    Override the class' `create()` method to raise an error. This
    prevents end users from inadvertently calling `create()` instead
    of `createRecord()`. The store is still able to create instances
    by calling the `_create()` method. To create an instance of a
    `DS.Model` use [store.createRecord](DS.Store.html#method_createRecord).
  itemtype: method
  name: create
  access: private
  tagname: ''
  static: 1
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1204
  description: |-
    Represents the model's class name as a string. This can be used to look up the model's class name through
    `DS.Store`'s modelFor method.

    `modelName` is generated for you by Ember Data. It will be a lowercased, dasherized string.
    For example:

    ```javascript
    store.modelFor('post').modelName; // 'post'
    store.modelFor('blog-post').modelName; // 'blog-post'
    ```

    The most common place you'll want to access `modelName` is in your serializer's `payloadKeyFromModelName` method. For example, to change payload
    keys to underscore (instead of dasherized), you might use the following code:

    ```javascript
    export default const PostSerializer = DS.RESTSerializer.extend({
      payloadKeyFromModelName: function(modelName) {
        return Ember.String.underscore(modelName);
      }
    });
    ```
  itemtype: property
  name: modelName
  type: String
  readonly: ''
  static: 1
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1250
  description: |-
    For a given relationship name, returns the model type of the relationship.

    For example, if you define a model like this:

    ```app/models/post.js
    import DS from 'ember-data';

    export default DS.Model.extend({
       comments: DS.hasMany('comment')
     });
    ```

    Calling `store.modelFor('post').typeForRelationship('comments', store)` will return `Comment`.
  itemtype: method
  name: typeForRelationship
  static: 1
  params:
  - name: name
    description: the name of the relationship
    type: String
  - name: store
    description: an instance of DS.Store
    type: Store
  return:
    description: the type of the relationship, or undefined
    type: DS.Model
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1280
  description: |-
    Find the relationship which is the inverse of the one asked for.

    For example, if you define models like this:

    ```app/models/post.js
    import DS from 'ember-data';

    export default DS.Model.extend({
       comments: DS.hasMany('message')
     });
    ```

    ```app/models/message.js
    import DS from 'ember-data';

    export default DS.Model.extend({
       owner: DS.belongsTo('post')
     });
    ```

    ``` js
    store.modelFor('post').inverseFor('comments', store) // { type: App.Message, name: 'owner', kind: 'belongsTo' }
    store.modelFor('message').inverseFor('owner', store) // { type: App.Post, name: 'comments', kind: 'hasMany' }
    ```
  itemtype: method
  name: inverseFor
  static: 1
  params:
  - name: name
    description: the name of the relationship
    type: String
  - name: store
    description: ''
    type: DS.Store
  return:
    description: the inverse relationship, or null
    type: Object
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1387
  description: |-
    The model's relationships as a map, keyed on the type of the
    relationship. The value of each entry is an array containing a descriptor
    for each relationship with that type, describing the name of the relationship
    as well as the type.

    For example, given the following model definition:

    ```app/models/blog.js
    import DS from 'ember-data';

    export default DS.Model.extend({
       users: DS.hasMany('user'),
       owner: DS.belongsTo('user'),
       posts: DS.hasMany('post')
     });
    ```

    This computed property would return a map describing these
    relationships, like this:

    ```javascript
    import Ember from 'ember';
    import Blog from 'app/models/blog';
    import User from 'app/models/user';
    import Post from 'app/models/post';

    let relationships = Ember.get(Blog, 'relationships');
    relationships.get(User);
    //=> [ { name: 'users', kind: 'hasMany' },
    //     { name: 'owner', kind: 'belongsTo' } ]
    relationships.get(Post);
    //=> [ { name: 'posts', kind: 'hasMany' } ]
    ```
  itemtype: property
  name: relationships
  static: 1
  type: Ember.Map
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1430
  description: |-
    A hash containing lists of the model's relationships, grouped
    by the relationship kind. For example, given a model with this
    definition:

    ```app/models/blog.js
    import DS from 'ember-data';

    export default DS.Model.extend({
       users: DS.hasMany('user'),
       owner: DS.belongsTo('user'),

       posts: DS.hasMany('post')
     });
    ```

    This property would contain the following:

    ```javascript
    import Ember from 'ember';
    import Blog from 'app/models/blog';

    let relationshipNames = Ember.get(Blog, 'relationshipNames');
    relationshipNames.hasMany;
    //=> ['users', 'posts']
    relationshipNames.belongsTo;
    //=> ['owner']
    ```
  itemtype: property
  name: relationshipNames
  static: 1
  type: Object
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1479
  description: |-
    An array of types directly related to a model. Each type will be
    included once, regardless of the number of relationships it has with
    the model.

    For example, given a model with this definition:

    ```app/models/blog.js
    import DS from 'ember-data';

    export default DS.Model.extend({
       users: DS.hasMany('user'),
       owner: DS.belongsTo('user'),

       posts: DS.hasMany('post')
     });
    ```

    This property would contain the following:

    ```javascript
    import Ember from 'ember';
    import Blog from 'app/models/blog';

    let relatedTypes = Ember.get(Blog, 'relatedTypes');
    //=> [ User, Post ]
    ```
  itemtype: property
  name: relatedTypes
  static: 1
  type: Ember.Array
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1514
  description: |-
    A map whose keys are the relationships of a model and whose values are
    relationship descriptors.

    For example, given a model with this
    definition:

    ```app/models/blog.js
    import DS from 'ember-data';

    export default DS.Model.extend({
       users: DS.hasMany('user'),
       owner: DS.belongsTo('user'),

       posts: DS.hasMany('post')
     });
    ```

    This property would contain the following:

    ```javascript
    import Ember from 'ember';
    import Blog from 'app/models/blog';

    let relationshipsByName = Ember.get(Blog, 'relationshipsByName');
    relationshipsByName.get('users');
    //=> { key: 'users', kind: 'hasMany', type: 'user', options: Object, isRelationship: true }
    relationshipsByName.get('owner');
    //=> { key: 'owner', kind: 'belongsTo', type: 'user', options: Object, isRelationship: true }
    ```
  itemtype: property
  name: relationshipsByName
  static: 1
  type: Ember.Map
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1552
  description: |-
    A map whose keys are the fields of the model and whose values are strings
    describing the kind of the field. A model's fields are the union of all of its
    attributes and relationships.

    For example:

    ```app/models/blog.js
    import DS from 'ember-data';

    export default DS.Model.extend({
       users: DS.hasMany('user'),
       owner: DS.belongsTo('user'),

       posts: DS.hasMany('post'),

       title: DS.attr('string')
     });
    ```

    ```js
    import Ember from 'ember';
    import Blog from 'app/models/blog';

    let fields = Ember.get(Blog, 'fields');
    fields.forEach(function(kind, field) {
       console.log(field, kind);
     });

    // prints:
    // users, hasMany
    // owner, belongsTo
    // posts, hasMany
    // title, attribute
    ```
  itemtype: property
  name: fields
  static: 1
  type: Ember.Map
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1607
  description: |-
    Given a callback, iterates over each of the relationships in the model,
    invoking the callback with the name of each relationship and its relationship
    descriptor.
  itemtype: method
  name: eachRelationship
  static: 1
  params:
  - name: callback
    description: the callback to invoke
    type: Function
  - name: binding
    description: the value to which the callback's `this` should be bound
    type: Any
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1623
  description: |-
    Given a callback, iterates over each of the types related to a model,
    invoking the callback with the related type's class. Each type will be
    returned just once, regardless of how many different relationships it has
    with a model.
  itemtype: method
  name: eachRelatedType
  static: 1
  params:
  - name: callback
    description: the callback to invoke
    type: Function
  - name: binding
    description: the value to which the callback's `this` should be bound
    type: Any
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1664
  description: |-
    A map whose keys are the attributes of the model (properties
    described by DS.attr) and whose values are the meta object for the
    property.

    Example

    ```app/models/person.js
    import DS from 'ember-data';

    export default DS.Model.extend({
       firstName: DS.attr('string'),
       lastName: DS.attr('string'),
       birthday: DS.attr('date')
     });
    ```

    ```javascript
    import Ember from 'ember';
    import Person from 'app/models/person';

    let attributes = Ember.get(Person, 'attributes')

    attributes.forEach(function(meta, name) {
       console.log(name, meta);
     });

    // prints:
    // firstName {type: "string", isAttribute: true, options: Object, parentType: function, name: "firstName"}
    // lastName {type: "string", isAttribute: true, options: Object, parentType: function, name: "lastName"}
    // birthday {type: "date", isAttribute: true, options: Object, parentType: function, name: "birthday"}
    ```
  itemtype: property
  name: attributes
  static: 1
  type: "{Ember.Map}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1717
  description: |-
    A map whose keys are the attributes of the model (properties
    described by DS.attr) and whose values are type of transformation
    applied to each attribute. This map does not include any
    attributes that do not have an transformation type.

    Example

    ```app/models/person.js
    import DS from 'ember-data';

    export default DS.Model.extend({
       firstName: DS.attr(),
       lastName: DS.attr('string'),
       birthday: DS.attr('date')
     });
    ```

    ```javascript
    import Ember from 'ember';
    import Person from 'app/models/person';

    let transformedAttributes = Ember.get(Person, 'transformedAttributes')

    transformedAttributes.forEach(function(field, type) {
       console.log(field, type);
     });

    // prints:
    // lastName string
    // birthday date
    ```
  itemtype: property
  name: transformedAttributes
  static: 1
  type: "{Ember.Map}"
  readonly: ''
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1767
  description: |-
    Iterates through the attributes of the model, calling the passed function on each
    attribute.

    The callback method you provide should have the following signature (all
    parameters are optional):

    ```javascript
    function(name, meta);
    ```

    - `name` the name of the current property in the iteration
    - `meta` the meta object for the attribute property in the iteration

    Note that in addition to a callback, you can also pass an optional target
    object that will be set as `this` on the context.

    Example

    ```javascript
    import DS from 'ember-data';

    let Person = DS.Model.extend({
       firstName: DS.attr('string'),
       lastName: DS.attr('string'),
       birthday: DS.attr('date')
     });

    Person.eachAttribute(function(name, meta) {
       console.log(name, meta);
     });

    // prints:
    // firstName {type: "string", isAttribute: true, options: Object, parentType: function, name: "firstName"}
    // lastName {type: "string", isAttribute: true, options: Object, parentType: function, name: "lastName"}
    // birthday {type: "date", isAttribute: true, options: Object, parentType: function, name: "birthday"}
    ```
  itemtype: method
  name: eachAttribute
  params:
  - name: callback
    description: The callback to execute
    type: Function
  - name: binding
    description: the value to which the callback's `this` should be bound
    type: Object
    optional: true
  static: 1
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1816
  description: |-
    Iterates through the transformedAttributes of the model, calling
    the passed function on each attribute. Note the callback will not be
    called for any attributes that do not have an transformation type.

    The callback method you provide should have the following signature (all
    parameters are optional):

    ```javascript
    function(name, type);
    ```

    - `name` the name of the current property in the iteration
    - `type` a string containing the name of the type of transformed
    applied to the attribute

    Note that in addition to a callback, you can also pass an optional target
    object that will be set as `this` on the context.

    Example

    ```javascript
    import DS from 'ember-data';

    let Person = DS.Model.extend({
       firstName: DS.attr(),
       lastName: DS.attr('string'),
       birthday: DS.attr('date')
     });

    Person.eachTransformedAttribute(function(name, type) {
       console.log(name, type);
     });

    // prints:
    // lastName string
    // birthday date
    ```
  itemtype: method
  name: eachTransformedAttribute
  params:
  - name: callback
    description: The callback to execute
    type: Function
  - name: binding
    description: the value to which the callback's `this` should be bound
    type: Object
    optional: true
  static: 1
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/model/model.js
  line: 1888
  description: |-
    Discards any unsaved changes to the given attribute. This feature is not enabled by default. You must enable `ds-rollback-attribute` and be running a canary build.

    Example

    ```javascript
    record.get('name'); // 'Untitled Document'
    record.set('name', 'Doc 1');
    record.get('name'); // 'Doc 1'
    record.rollbackAttribute('name');
    record.get('name'); // 'Untitled Document'
    ```
  itemtype: method
  name: rollbackAttribute
  class: DS.Model
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/adapter-populated-record-array.js
  line: 69
  itemtype: method
  name: _setInternalModels
  params:
  - name: internalModels
    description: ''
    type: Array
  - name: payload
    description: normalized payload
    type: Object
  access: private
  tagname: ''
  class: DS.AdapterPopulatedRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/filtered-record-array.js
  line: 27
  description: |-
    The filterFunction is a function used to test records from the store to
    determine if they should be part of the record array.

    Example

    ```javascript
    var allPeople = store.peekAll('person');
    allPeople.mapBy('name'); // ["Tom Dale", "Yehuda Katz", "Trek Glowacki"]

    var people = store.filter('person', function(person) {
      if (person.get('name').match(/Katz$/)) { return true; }
    });
    people.mapBy('name'); // ["Yehuda Katz"]

    var notKatzFilter = function(person) {
      return !person.get('name').match(/Katz$/);
    };
    people.set('filterFunction', notKatzFilter);
    people.mapBy('name'); // ["Tom Dale", "Trek Glowacki"]
    ```
  itemtype: method
  name: filterFunction
  params:
  - name: record
    description: ''
    type: DS.Model
  return:
    description: "`true` if the record should be in the array"
    type: Boolean
  class: DS.FilteredRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/filtered-record-array.js
  line: 58
  itemtype: method
  name: updateFilter
  access: private
  tagname: ''
  class: DS.FilteredRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 28
  description: |-
    The array of client ids backing the record array. When a
    record is requested from the record array, the record
    for the client id at the same index is materialized, if
    necessary, by the store.
  itemtype: property
  name: content
  access: private
  tagname: ''
  type: Ember.Array
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 40
  description: |-
    The flag to signal a `RecordArray` is finished loading data.

    Example

    ```javascript
    var people = store.peekAll('person');
    people.get('isLoaded'); // true
    ```
  itemtype: property
  name: isLoaded
  type: Boolean
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 54
  description: |-
    The flag to signal a `RecordArray` is currently loading data.

    Example

    ```javascript
    var people = store.peekAll('person');
    people.get('isUpdating'); // false
    people.update();
    people.get('isUpdating'); // true
    ```
  itemtype: property
  name: isUpdating
  type: Boolean
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 71
  description: The store that created this record array.
  itemtype: property
  name: store
  access: private
  tagname: ''
  type: DS.Store
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 86
  description: The modelClass represented by this record array.
  itemtype: property
  name: type
  type: DS.Model
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 99
  description: Retrieves an object from the content by index.
  itemtype: method
  name: objectAtContent
  access: private
  tagname: ''
  params:
  - name: index
    description: ''
    type: Number
  return:
    description: record
    type: DS.Model
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 112
  description: |-
    Used to get the latest version of all of the records in this array
    from the adapter.

    Example

    ```javascript
    var people = store.peekAll('person');
    people.get('isUpdating'); // false

    people.update().then(function() {
      people.get('isUpdating'); // false
    });

    people.get('isUpdating'); // true
    ```
  itemtype: method
  name: update
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 155
  description: Adds an internal model to the `RecordArray` without duplicates
  itemtype: method
  name: addInternalModel
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: ''
    type: InternalModel
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 169
  description: Removes an internalModel to the `RecordArray`.
  itemtype: method
  name: removeInternalModel
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: ''
    type: InternalModel
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 180
  description: |-
    Saves all of the records in the `RecordArray`.

    Example

    ```javascript
    var messages = store.peekAll('message');
    messages.forEach(function(message) {
      message.set('hasBeenSeen', true);
    });
    messages.save();
    ```
  itemtype: method
  name: save
  return:
    description: promise
    type: DS.PromiseArray
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-arrays/record-array.js
  line: 214
  itemtype: method
  name: _unregisterFromManager
  access: private
  tagname: ''
  class: DS.RecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/belongs-to.js
  line: 31
  description: |-
    This returns a string that represents how the reference will be
    looked up when it is loaded. If the relationship has a link it will
    use the "link" otherwise it defaults to "id".

    Example

    ```javascript
     // models/blog.js
     export default DS.Model.extend({
       user: DS.belongsTo({ async: true })
     });

     let blog = store.push({
       type: 'blog',
       id: 1,
       relationships: {
         user: {
           data: { type: 'user', id: 1 }
         }
       }
     });
     let userRef = blog.belongsTo('user');

     // get the identifier of the reference
     if (userRef.remoteType() === "id") {
       let id = userRef.id();
     } else if (userRef.remoteType() === "link") {
       let link = userRef.link();
     }
     ```
  itemtype: method
  name: remoteType
  return:
    description: The name of the remote type. This should either be "link" or "id"
    type: String
  class: DS.BelongsToReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/belongs-to.js
  line: 74
  description: |-
    The `id` of the record that this reference refers to. Together, the
    `type()` and `id()` methods form a composite key for the identity
    map. This can be used to access the id of an async relationship
    without triggering a fetch that would normally happen if you
    attempted to use `record.get('relationship.id')`.

    Example

    ```javascript
     // models/blog.js
     export default DS.Model.extend({
       user: DS.belongsTo({ async: true })
     });

     let blog = store.push({
       data: {
         type: 'blog',
         id: 1,
         relationships: {
           user: {
             data: { type: 'user', id: 1 }
           }
         }
       }
     });
     let userRef = blog.belongsTo('user');

     // get the identifier of the reference
     if (userRef.remoteType() === "id") {
       let id = userRef.id();
     }
     ```
  itemtype: method
  name: id
  return:
    description: The id of the record in this belongsTo relationship.
    type: String
  class: DS.BelongsToReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/belongs-to.js
  line: 116
  description: |-
    The link Ember Data will use to fetch or reload this belongs-to
    relationship.

    Example

    ```javascript
     // models/blog.js
     export default DS.Model.extend({
       user: DS.belongsTo({ async: true })
     });

     let blog = store.push({
       data: {
         type: 'blog',
         id: 1,
         relationships: {
           user: {
             links: {
               related: '/articles/1/author'
             }
           }
         }
       }
     });
     let userRef = blog.belongsTo('user');

     // get the identifier of the reference
     if (userRef.remoteType() === "link") {
       let link = userRef.link();
     }
     ```
  itemtype: method
  name: link
  return:
    description: The link Ember Data will use to fetch or reload this belongs-to relationship.
    type: String
  class: DS.BelongsToReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/belongs-to.js
  line: 156
  description: |-
    The meta data for the belongs-to relationship.

    Example

    ```javascript
     // models/blog.js
     export default DS.Model.extend({
       user: DS.belongsTo({ async: true })
     });

     let blog = store.push({
       data: {
         type: 'blog',
         id: 1,
         relationships: {
           user: {
             links: {
               related: {
                 href: '/articles/1/author',
                 meta: {
                   lastUpdated: 1458014400000
                 }
               }
             }
           }
         }
       }
     });

     let userRef = blog.belongsTo('user');

     userRef.meta() // { lastUpdated: 1458014400000 }
     ```
  itemtype: method
  name: meta
  return:
    description: The meta information for the belongs-oo relationship.
    type: Object
  class: DS.BelongsToReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/belongs-to.js
  line: 198
  description: |-
    `push` can be used to update the data in the relationship and Ember
    Data will treat the new data as the conanical value of this
    relationship on the backend.

    Example

     ```javascript
     // models/blog.js
     export default DS.Model.extend({
       user: DS.belongsTo({ async: true })
     });

     let blog = store.push({
       data: {
         type: 'blog',
         id: 1,
         relationships: {
           user: {
             data: { type: 'user', id: 1 }
           }
         }
       }
     });
     let userRef = blog.belongsTo('user');

     // provide data for reference
     userRef.push({
       data: {
         type: 'user',
         id: 1,
         attributes: {
           username: "@user"
         }
       }
     }).then(function(user) {
       userRef.value() === user;
     });
     ```
  itemtype: method
  name: push
  params:
  - name: objectOrPromise
    description: a promise that resolves to a JSONAPI document object describing the
      new value of this relationship.
    type: Object|Promise
  return:
    description: A promise that resolves with the new value in this belongs-to relationship.
    type: Promise<record>
  class: DS.BelongsToReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/belongs-to.js
  line: 266
  description: |-
    `value()` synchronously returns the current value of the belongs-to
    relationship. Unlike `record.get('relationshipName')`, calling
    `value()` on a reference does not trigger a fetch if the async
    relationship is not yet loaded. If the relationship is not loaded
    it will always return `null`.

    Example

     ```javascript
     // models/blog.js
     export default DS.Model.extend({
       user: DS.belongsTo({ async: true })
     });

     let blog = store.push({
       data: {
         type: 'blog',
         id: 1,
         relationships: {
           user: {
             data: { type: 'user', id: 1 }
           }
         }
       }
     });
     let userRef = blog.belongsTo('user');

     userRef.value(); // null

     // provide data for reference
     userRef.push({
       data: {
         type: 'user',
         id: 1,
         attributes: {
           username: "@user"
         }
       }
     }).then(function(user) {
       userRef.value(); // user
     });
     ```
  itemtype: method
  name: value
  params:
  - name: objectOrPromise
    description: a promise that resolves to a JSONAPI document object describing the
      new value of this relationship.
    type: Object|Promise
  return:
    description: the record in this relationship
    type: DS.Model
  class: DS.BelongsToReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/belongs-to.js
  line: 324
  description: |-
    Loads a record in a belongs to relationship if it is not already
    loaded. If the relationship is already loaded this method does not
    trigger a new load.

    Example

     ```javascript
     // models/blog.js
     export default DS.Model.extend({
       user: DS.belongsTo({ async: true })
     });

     let blog = store.push({
       data: {
         type: 'blog',
         id: 1,
         relationships: {
           user: {
             data: { type: 'user', id: 1 }
           }
         }
       }
     });
     let userRef = blog.belongsTo('user');

     userRef.value(); // null

     userRef.load().then(function(user) {
       userRef.value() === user
     });
  itemtype: method
  name: load
  return:
    description: a promise that resolves with the record in this belongs-to relationship.
    type: Promise
  class: DS.BelongsToReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/belongs-to.js
  line: 371
  description: |-
    Triggers a reload of the value in this relationship. If the
    remoteType is `"link"` Ember Data will use the relationship link to
    reload the relationship. Otherwise it will reload the record by its
    id.

    Example

     ```javascript
     // models/blog.js
     export default DS.Model.extend({
       user: DS.belongsTo({ async: true })
     });

     let blog = store.push({
       data: {
         type: 'blog',
         id: 1,
         relationships: {
           user: {
             data: { type: 'user', id: 1 }
           }
         }
       }
     });
     let userRef = blog.belongsTo('user');

     userRef.reload().then(function(user) {
       userRef.value() === user
     });
  itemtype: method
  name: reload
  return:
    description: a promise that resolves with the record in this belongs-to relationship
      after the reload has completed.
    type: Promise
  class: DS.BelongsToReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/has-many.js
  line: 36
  description: |-
    This returns a string that represents how the reference will be
    looked up when it is loaded. If the relationship has a link it will
    use the "link" otherwise it defaults to "id".

    Example

    ```app/models/post.js
    export default DS.Model.extend({
      comments: DS.hasMany({ async: true })
    });
    ```

    ```javascript
    let post = store.push({
      data: {
        type: 'post',
        id: 1,
        relationships: {
          comments: {
            data: [{ type: 'comment', id: 1 }]
          }
        }
      }
    });

    let commentsRef = post.hasMany('comments');

    // get the identifier of the reference
    if (commentsRef.remoteType() === "ids") {
      let ids = commentsRef.ids();
    } else if (commentsRef.remoteType() === "link") {
      let link = commentsRef.link();
    }
    ```
  itemtype: method
  name: remoteType
  return:
    description: The name of the remote type. This should either be "link" or "ids"
    type: String
  class: DS.HasManyReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/has-many.js
  line: 83
  description: |-
    The link Ember Data will use to fetch or reload this has-many
    relationship.

    Example

    ```app/models/post.js
    export default DS.Model.extend({
      comments: DS.hasMany({ async: true })
    });
    ```

    ```javascript
    let post = store.push({
      data: {
        type: 'post',
        id: 1,
        relationships: {
          comments: {
            links: {
              related: '/posts/1/comments'
            }
          }
        }
      }
    });

    let commentsRef = post.hasMany('comments');

    commentsRef.link(); // '/posts/1/comments'
    ```
  itemtype: method
  name: link
  return:
    description: The link Ember Data will use to fetch or reload this has-many relationship.
    type: String
  class: DS.HasManyReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/has-many.js
  line: 122
  description: |-
    `ids()` returns an array of the record ids in this relationship.

    Example

    ```app/models/post.js
    export default DS.Model.extend({
      comments: DS.hasMany({ async: true })
    });
    ```

    ```javascript
    let post = store.push({
      data: {
        type: 'post',
        id: 1,
        relationships: {
          comments: {
            data: [{ type: 'comment', id: 1 }]
          }
        }
      }
    });

    let commentsRef = post.hasMany('comments');

    commentsRef.ids(); // ['1']
    ```
  itemtype: method
  name: remoteType
  return:
    description: The ids in this has-many relationship
    type: Array
  class: DS.HasManyReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/has-many.js
  line: 162
  description: |-
    The link Ember Data will use to fetch or reload this has-many
    relationship.

    Example

    ```app/models/post.js
    export default DS.Model.extend({
      comments: DS.hasMany({ async: true })
    });
    ```

    ```javascript
    let post = store.push({
      data: {
        type: 'post',
        id: 1,
        relationships: {
          comments: {
            links: {
              related: {
                href: '/posts/1/comments',
                meta: {
                  count: 10
                }
              }
            }
          }
        }
      }
    });

    let commentsRef = post.hasMany('comments');

    commentsRef.meta(); // { count: 10 }
    ```
  itemtype: method
  name: meta
  return:
    description: The meta information for the has-many relationship.
    type: Object
  class: DS.HasManyReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/has-many.js
  line: 206
  description: |-
    `push` can be used to update the data in the relationship and Ember
    Data will treat the new data as the canonical value of this
    relationship on the backend.

    Example

    ```app/models/post.js
    export default DS.Model.extend({
      comments: DS.hasMany({ async: true })
    });
    ```

    ```
    let post = store.push({
      data: {
        type: 'post',
        id: 1,
        relationships: {
          comments: {
            data: [{ type: 'comment', id: 1 }]
          }
        }
      }
    });

    let commentsRef = post.hasMany('comments');

    commentsRef.ids(); // ['1']

    commentsRef.push([
      [{ type: 'comment', id: 2 }],
      [{ type: 'comment', id: 3 }],
    ])

    commentsRef.ids(); // ['2', '3']
    ```
  itemtype: method
  name: push
  params:
  - name: objectOrPromise
    description: a promise that resolves to a JSONAPI document object describing the
      new value of this relationship.
    type: Array|Promise
  return:
    description: ''
    type: DS.ManyArray
  class: DS.HasManyReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/has-many.js
  line: 319
  description: |-
    `value()` sycronously returns the current value of the has-many
     relationship. Unlike `record.get('relationshipName')`, calling
     `value()` on a reference does not trigger a fetch if the async
     relationship is not yet loaded. If the relationship is not loaded
     it will always return `null`.

    Example

    ```app/models/post.js
    export default DS.Model.extend({
      comments: DS.hasMany({ async: true })
    });
    ```

    ```javascript
    let post = store.push({
      data: {
        type: 'post',
        id: 1,
        relationships: {
          comments: {
            data: [{ type: 'comment', id: 1 }]
          }
        }
      }
    });

    let commentsRef = post.hasMany('comments');

    post.get('comments').then(function(comments) {
      commentsRef.value() === comments
    })
    ```
  itemtype: method
  name: value
  return:
    description: ''
    type: DS.ManyArray
  class: DS.HasManyReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/has-many.js
  line: 365
  description: |-
    Loads the relationship if it is not already loaded.  If the
    relationship is already loaded this method does not trigger a new
    load.

    Example

    ```app/models/post.js
    export default DS.Model.extend({
      comments: DS.hasMany({ async: true })
    });
    ```

    ```javascript
    let post = store.push({
      data: {
        type: 'post',
        id: 1,
        relationships: {
          comments: {
            data: [{ type: 'comment', id: 1 }]
          }
        }
      }
    });

    let commentsRef = post.hasMany('comments');

    commentsRef.load().then(function(comments) {
      //...
    });
    ```
  itemtype: method
  name: load
  return:
    description: |-
      a promise that resolves with the ManyArray in
      this has-many relationship.
    type: Promise
  class: DS.HasManyReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/has-many.js
  line: 410
  description: |-
    Reloads this has-many relationship.

    Example

    ```app/models/post.js
    export default DS.Model.extend({
      comments: DS.hasMany({ async: true })
    });
    ```

    ```javascript
    let post = store.push({
      data: {
        type: 'post',
        id: 1,
        relationships: {
          comments: {
            data: [{ type: 'comment', id: 1 }]
          }
        }
      }
    });

    let commentsRef = post.hasMany('comments');

    commentsRef.reload().then(function(comments) {
      //...
    });
    ```
  itemtype: method
  name: reload
  return:
    description: a promise that resolves with the ManyArray in this has-many relationship.
    type: Promise
  class: DS.HasManyReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/record.js
  line: 21
  description: |-
    The `id` of the record that this reference refers to.

    Together, the `type` and `id` properties form a composite key for
    the identity map.

    Example

    ```javascript
    let userRef = store.getReference('user', 1);

    userRef.id(); // '1'
    ```
  itemtype: method
  name: id
  return:
    description: The id of the record.
    type: String
  class: DS.RecordReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/record.js
  line: 42
  description: |-
    How the reference will be looked up when it is loaded: Currently
    this always return `identity` to signifying that a record will be
    loaded by the `type` and `id`.

    Example

    ```javascript
    const userRef = store.getReference('user', 1);

    userRef.remoteType(); // 'identity'
    ```
  itemtype: method
  name: remoteType
  return:
    description: "'identity'"
    type: String
  class: DS.RecordReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/record.js
  line: 62
  description: |-
    This API allows you to provide a reference with new data. The
    simplest usage of this API is similar to `store.push`: you provide a
    normalized hash of data and the object represented by the reference
    will update.

    If you pass a promise to `push`, Ember Data will not ask the adapter
    for the data if another attempt to fetch it is made in the
    interim. When the promise resolves, the underlying object is updated
    with the new data, and the promise returned by *this function* is resolved
    with that object.

    For example, `recordReference.push(promise)` will be resolved with a
    record.

     Example

     ```javascript
     let userRef = store.getReference('user', 1);

     // provide data for reference
     userRef.push({ data: { id: 1, username: "@user" }}).then(function(user) {
       userRef.value() === user;
     });
     ```
  itemtype: method
  name: push
  params:
  - name: UNKNOWN
    description: ''
    type: Promise|Object
  return:
    description: Promise<record> a promise for the value (record or relationship)
  class: DS.RecordReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/record.js
  line: 98
  description: |-
    If the entity referred to by the reference is already loaded, it is
    present as `reference.value`. Otherwise the value returned by this function
    is `null`.

     Example

     ```javascript
     let userRef = store.getReference('user', 1);

     userRef.value(); // user
     ```
  itemtype: method
  name: value
  return:
    description: the record for this RecordReference
    type: DS.Model
  class: DS.RecordReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/record.js
  line: 118
  description: |-
    Triggers a fetch for the backing entity based on its `remoteType`
    (see `remoteType` definitions per reference type).

    Example

    ```javascript
    let userRef = store.getReference('user', 1);

    // load user (via store.find)
    userRef.load().then(...)
    ```
  itemtype: method
  name: load
  return:
    description: the record for this RecordReference
    type: Promise<record>
  class: DS.RecordReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/references/record.js
  line: 138
  description: |-
    Reloads the record if it is already loaded. If the record is not
    loaded it will load the record via `store.findRecord`

    Example

    ```javascript
    let userRef = store.getReference('user', 1);

    // or trigger a reload
    userRef.reload().then(...)
    ```
  itemtype: method
  name: reload
  return:
    description: the record for this RecordReference
    type: Promise<record>
  class: DS.RecordReference
  module: ember-data
  namespace: DS
- file: addon/-private/system/relationships/belongs-to.js
  line: 5
  description: |-
    `DS.belongsTo` is used to define One-To-One and One-To-Many
    relationships on a [DS.Model](/api/data/classes/DS.Model.html).


    `DS.belongsTo` takes an optional hash as a second parameter, currently
    supported options are:

    - `async`: A boolean value used to explicitly declare this to be an async relationship.
    - `inverse`: A string used to identify the inverse property on a
      related model in a One-To-Many relationship. See [Explicit Inverses](#toc_explicit-inverses)

    #### One-To-One
    To declare a one-to-one relationship between two models, use
    `DS.belongsTo`:

    ```app/models/user.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      profile: DS.belongsTo('profile')
    });
    ```

    ```app/models/profile.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      user: DS.belongsTo('user')
    });
    ```

    #### One-To-Many
    To declare a one-to-many relationship between two models, use
    `DS.belongsTo` in combination with `DS.hasMany`, like this:

    ```app/models/post.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      comments: DS.hasMany('comment')
    });
    ```

    ```app/models/comment.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      post: DS.belongsTo('post')
    });
    ```

    You can avoid passing a string as the first parameter. In that case Ember Data
    will infer the type from the key name.

    ```app/models/comment.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      post: DS.belongsTo()
    });
    ```

    will lookup for a Post type.
  itemtype: method
  name: belongsTo
  params:
  - name: modelName
    description: "(optional) type of the relationship"
    type: String
  - name: options
    description: "(optional) a hash of options"
    type: Object
  return:
    description: relationship
    type: Ember.computed
  class: DS
  module: ember-data
- file: addon/-private/system/relationships/has-many.js
  line: 12
  description: |-
    `DS.hasMany` is used to define One-To-Many and Many-To-Many
    relationships on a [DS.Model](/api/data/classes/DS.Model.html).

    `DS.hasMany` takes an optional hash as a second parameter, currently
    supported options are:

    - `async`: A boolean value used to explicitly declare this to be an async relationship.
    - `inverse`: A string used to identify the inverse property on a related model.

    #### One-To-Many
    To declare a one-to-many relationship between two models, use
    `DS.belongsTo` in combination with `DS.hasMany`, like this:

    ```app/models/post.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      comments: DS.hasMany('comment')
    });
    ```

    ```app/models/comment.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      post: DS.belongsTo('post')
    });
    ```

    #### Many-To-Many
    To declare a many-to-many relationship between two models, use
    `DS.hasMany`:

    ```app/models/post.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      tags: DS.hasMany('tag')
    });
    ```

    ```app/models/tag.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      posts: DS.hasMany('post')
    });
    ```

    You can avoid passing a string as the first parameter. In that case Ember Data
    will infer the type from the singularized key name.

    ```app/models/post.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      tags: DS.hasMany()
    });
    ```

    will lookup for a Tag type.

    #### Explicit Inverses

    Ember Data will do its best to discover which relationships map to
    one another. In the one-to-many code above, for example, Ember Data
    can figure out that changing the `comments` relationship should update
    the `post` relationship on the inverse because post is the only
    relationship to that model.

    However, sometimes you may have multiple `belongsTo`/`hasMany` for the
    same type. You can specify which property on the related model is
    the inverse using `DS.hasMany`'s `inverse` option:

    ```app/models/comment.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      onePost: DS.belongsTo('post'),
      twoPost: DS.belongsTo('post'),
      redPost: DS.belongsTo('post'),
      bluePost: DS.belongsTo('post')
    });
    ```

    ```app/models/post.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      comments: DS.hasMany('comment', {
        inverse: 'redPost'
      })
    });
    ```

    You can also specify an inverse on a `belongsTo`, which works how
    you'd expect.
  itemtype: method
  name: hasMany
  params:
  - name: type
    description: "(optional) type of the relationship"
    type: String
  - name: options
    description: "(optional) a hash of options"
    type: Object
  return:
    description: relationship
    type: Ember.computed
  class: DS
  module: ember-data
- file: addon/-private/system/diff-array.js
  line: 1
  itemtype: method
  name: diff-array
  params:
  - name: oldArray
    description: the old array
    type: Array
  - name: newArray
    description: the new array
    type: Array
  return:
    description: |-
      {
          firstChangeIndex: <integer>,  // null if no change
          addedCount: <integer>,        // 0 if no change
          removedCount: <integer>       // 0 if no change
        }
    type: Hash
  class: DS
  module: ember-data
- file: addon/-private/system/identity-map.js
  line: 16
  description: |-
    Retrieves the `InternalModelMap` for a given modelName,
    creating one if one did not already exist. This is
    similar to `getWithDefault` or `get` on a `MapWithDefault`
  itemtype: method
  name: retrieve
  params:
  - name: modelName
    description: a previously normalized modelName
  return:
    description: the InternalModelMap for the given modelName
    type: InternalModelMap
  class: IdentityMap
  module: ember-data
- file: addon/-private/system/identity-map.js
  line: 35
  description: |-
    Clears the contents of all known `RecordMaps`, but does
    not remove the InternalModelMap instances.
  itemtype: method
  name: clear
  class: IdentityMap
  module: ember-data
- file: addon/-private/system/internal-model-map.js
  line: 22
  description: A "map" of records based on their ID for this modelName
  class: InternalModelMap
  module: ember-data
- file: addon/-private/system/internal-model-map.js
  line: 33
  params:
  - name: id
    description: ''
  return:
    description: ''
    type: InternalModel
  class: InternalModelMap
  module: ember-data
- file: addon/-private/system/internal-model-map.js
  line: 86
  description: An array of all models of this modelName
  class: InternalModelMap
  module: ember-data
- file: addon/-private/system/internal-model-map.js
  line: 93
  description: meta information about internalModels
  class: InternalModelMap
  module: ember-data
- file: addon/-private/system/internal-model-map.js
  line: 100
  description: deprecated (and unsupported) way of accessing modelClass
  deprecated: true
  class: InternalModelMap
  module: ember-data
- file: addon/-private/system/internal-model-map.js
  line: 109
  description: Destroy all models in the internalModelTest and wipe metadata.
  itemtype: method
  name: clear
  class: InternalModelMap
  module: ember-data
- file: addon/-private/system/many-array.js
  line: 59
  description: The loading state of this array
  itemtype: property
  name: isLoaded
  type: Boolean
  class: DS.ManyArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/many-array.js
  line: 67
  description: |-
    Used for async `hasMany` arrays
    to keep track of when they will resolve.
  itemtype: property
  name: promise
  type: Ember.RSVP.Promise
  access: private
  tagname: ''
  class: DS.ManyArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/many-array.js
  line: 76
  description: |-
    Metadata associated with the request for async hasMany relationships.

    Example

    Given that the server returns the following JSON payload when fetching a
    hasMany relationship:

    ```js
    {
      "comments": [{
        "id": 1,
        "comment": "This is the first comment",
      }, {
    // ...
      }],

      "meta": {
        "page": 1,
        "total": 5
      }
    }
    ```

    You can then access the metadata via the `meta` property:

    ```js
    post.get('comments').then(function(comments) {
      var meta = comments.get('meta');

    // meta.page => 1
    // meta.total => 5
    });
    ```
  itemtype: property
  name: meta
  type: Object
  access: public
  tagname: ''
  class: DS.ManyArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/many-array.js
  line: 116
  description: "`true` if the relationship is polymorphic, `false` otherwise."
  itemtype: property
  name: isPolymorphic
  type: Boolean
  access: private
  tagname: ''
  class: DS.ManyArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/many-array.js
  line: 124
  description: The relationship which manages this array.
  itemtype: property
  name: relationship
  type: ManyRelationship
  access: private
  tagname: ''
  class: DS.ManyArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/many-array.js
  line: 215
  itemtype: method
  name: loadingRecordsCount
  params:
  - name: count
    description: ''
    type: Number
  access: private
  tagname: ''
  class: DS.ManyArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/many-array.js
  line: 224
  itemtype: method
  name: loadedRecord
  access: private
  tagname: ''
  class: DS.ManyArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/many-array.js
  line: 236
  description: |-
    Reloads all of the records in the manyArray. If the manyArray
    holds a relationship that was originally fetched using a links url
    Ember Data will revisit the original links url to repopulate the
    relationship.

    If the manyArray holds the result of a `store.query()` reload will
    re-run the original query.

    Example

    ```javascript
    var user = store.peekRecord('user', 1)
    user.login().then(function() {
      user.get('permissions').then(function(permissions) {
        return permissions.reload();
      });
    });
    ```
  itemtype: method
  name: reload
  access: public
  tagname: ''
  class: DS.ManyArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/many-array.js
  line: 263
  description: |-
    Saves all of the records in the `ManyArray`.

    Example

    ```javascript
    store.findRecord('inbox', 1).then(function(inbox) {
      inbox.get('messages').then(function(messages) {
        messages.forEach(function(message) {
          message.set('isRead', true);
        });
        messages.save()
      });
    });
    ```
  itemtype: method
  name: save
  return:
    description: promise
    type: DS.PromiseArray
  class: DS.ManyArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/many-array.js
  line: 291
  description: Create a child record within the owner
  itemtype: method
  name: createRecord
  access: private
  tagname: ''
  params:
  - name: hash
    description: ''
    type: Object
  return:
    description: record
    type: DS.Model
  class: DS.ManyArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/normalize-model-name.js
  line: 6
  description: |-
    This method normalizes a modelName into the format Ember Data uses
    internally.
  itemtype: method
  name: normalizeModelName
  access: public
  tagname: ''
  params:
  - name: modelName
    description: ''
    type: String
  return:
    description: normalizedModelName
    type: String
  class: DS
  module: ember-data
- file: addon/-private/system/record-array-manager.js
  line: 103
  description: |-
    This method is invoked whenever data is loaded into the store by the
    adapter or updated by the adapter, or when a record has changed.

    It updates all record arrays that a record belongs to.

    To avoid thrashing, it only runs at most once per run loop.
  itemtype: method
  name: updateRecordArrays
  class: DS.RecordArrayManager
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-array-manager.js
  line: 196
  description: Update an individual filter.
  itemtype: method
  name: updateFilterRecordArray
  params:
  - name: array
    description: ''
    type: DS.FilteredRecordArray
  - name: filter
    description: ''
    type: Function
  - name: modelName
    description: ''
    type: String
  - name: internalModel
    description: ''
    type: InternalModel
  class: DS.RecordArrayManager
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-array-manager.js
  line: 260
  description: |-
    This method is invoked if the `filterFunction` property is
    changed on a `DS.FilteredRecordArray`.

    It essentially re-runs the filter from scratch. This same
    method is invoked when the filter is created in th first place.
  itemtype: method
  name: updateFilter
  params:
  - name: array
    description: ''
    type: Array
  - name: modelName
    description: ''
    type: String
  - name: filter
    description: ''
    type: Function
  class: DS.RecordArrayManager
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-array-manager.js
  line: 287
  description: |-
    Get the `DS.RecordArray` for a modelName, which contains all loaded records of
    given modelName.
  itemtype: method
  name: liveRecordArrayFor
  params:
  - name: modelName
    description: ''
    type: String
  return:
    description: ''
    type: DS.RecordArray
  class: DS.RecordArrayManager
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-array-manager.js
  line: 302
  description: Create a `DS.RecordArray` for a modelName.
  itemtype: method
  name: createRecordArray
  params:
  - name: modelName
    description: ''
    type: String
  return:
    description: ''
    type: DS.RecordArray
  class: DS.RecordArrayManager
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-array-manager.js
  line: 321
  description: Create a `DS.FilteredRecordArray` for a modelName and register it for
    updates.
  itemtype: method
  name: createFilteredRecordArray
  params:
  - name: modelName
    description: ''
    type: String
  - name: filter
    description: ''
    type: Function
  - name: query
    description: "(optional"
    type: Object
  return:
    description: ''
    type: DS.FilteredRecordArray
  class: DS.RecordArrayManager
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-array-manager.js
  line: 348
  description: Create a `DS.AdapterPopulatedRecordArray` for a modelName with given
    query.
  itemtype: method
  name: createAdapterPopulatedRecordArray
  params:
  - name: modelName
    description: ''
    type: String
  - name: query
    description: ''
    type: Object
  return:
    description: ''
    type: DS.AdapterPopulatedRecordArray
  class: DS.RecordArrayManager
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-array-manager.js
  line: 373
  description: |-
    Register a RecordArray for a given modelName to be backed by
    a filter function. This will cause the array to update
    automatically when records of that modelName change attribute
    values or states.
  itemtype: method
  name: registerFilteredRecordArray
  params:
  - name: array
    description: ''
    type: DS.RecordArray
  - name: modelName
    description: ''
    type: String
  - name: filter
    description: ''
    type: Function
  class: DS.RecordArrayManager
  module: ember-data
  namespace: DS
- file: addon/-private/system/record-array-manager.js
  line: 394
  description: |-
    Unregister a RecordArray.
    So manager will not update this array.
  itemtype: method
  name: unregisterRecordArray
  params:
  - name: array
    description: ''
    type: DS.RecordArray
  class: DS.RecordArrayManager
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot-record-array.js
  line: 14
  description: An array of snapshots
  access: private
  tagname: ''
  itemtype: property
  name: _snapshots
  type: "{Array}"
  class: DS.SnapshotRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot-record-array.js
  line: 21
  description: An array of records
  access: private
  tagname: ''
  itemtype: property
  name: _recordArray
  type: "{Array}"
  class: DS.SnapshotRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot-record-array.js
  line: 29
  description: |-
    Number of records in the array

    Example

    ```app/adapters/post.js
    import DS from 'ember-data'

    export default DS.JSONAPIAdapter.extend({
      shouldReloadAll(store, snapshotRecordArray) {
        return !snapshotRecordArray.length;
      },
    });
    ```
  itemtype: property
  name: length
  type: "{Number}"
  class: DS.SnapshotRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot-record-array.js
  line: 49
  description: The type of the underlying records for the snapshots in the array,
    as a DS.Model
  itemtype: property
  name: type
  type: "{DS.Model}"
  class: DS.SnapshotRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot-record-array.js
  line: 56
  description: |-
    Meta objects for the record array.

    Example

    ```app/adapters/post.js
    import DS from 'ember-data'

    export default DS.JSONAPIAdapter.extend({
      shouldReloadAll(store, snapshotRecordArray) {
        var lastRequestTime = snapshotRecordArray.meta.lastRequestTime;
        var twentyMinutes = 20 * 60 * 1000;
        return Date.now() > lastRequestTime + twentyMinutes;
      },
    });
    ```
  itemtype: property
  name: meta
  type: "{Object}"
  class: DS.SnapshotRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot-record-array.js
  line: 78
  description: |-
    A hash of adapter options passed into the store method for this request.

    Example

    ```app/adapters/post.js
    import MyCustomAdapter from './custom-adapter';

    export default MyCustomAdapter.extend({
      findAll(store, type, sinceToken, snapshotRecordArray) {
        if (snapshotRecordArray.adapterOptions.subscribe) {
          // ...
        }
        // ...
      }
    });
    ```
  itemtype: property
  name: adapterOptions
  type: "{Object}"
  class: DS.SnapshotRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot-record-array.js
  line: 101
  description: |-
    The relationships to include for this request.

    Example

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      findAll(store, type, snapshotRecordArray) {
        var url = `/${type.modelName}?include=${encodeURIComponent(snapshotRecordArray.include)}`;

        return fetch(url).then((response) => response.json())
      }
    });
  itemtype: property
  name: include
  type: "{String|Array}"
  class: DS.SnapshotRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot-record-array.js
  line: 123
  description: |-
    Get snapshots of the underlying record array

    Example

    ```app/adapters/post.js
    import DS from 'ember-data'

    export default DS.JSONAPIAdapter.extend({
      shouldReloadAll(store, snapshotArray) {
        var snapshots = snapshotArray.snapshots();

        return snapshots.any(function(ticketSnapshot) {
          var timeDiff = moment().diff(ticketSnapshot.attr('lastAccessedAt'), 'minutes');
          if (timeDiff > 20) {
            return true;
          } else {
            return false;
          }
        });
      }
    });
    ```
  itemtype: method
  name: snapshots
  return:
    description: Array of snapshots
    type: Array
  class: DS.SnapshotRecordArray
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 29
  description: |-
    The underlying record for this snapshot. Can be used to access methods and
    properties defined on the record.

    Example

    ```javascript
    let json = snapshot.record.toJSON();
    ```
  itemtype: property
  name: record
  type: "{DS.Model}"
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 45
  description: |-
    The id of the snapshot's underlying record

    Example

    ```javascript
    // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });
    postSnapshot.id; // => '1'
    ```
  itemtype: property
  name: id
  type: "{String}"
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 60
  description: A hash of adapter options
  itemtype: property
  name: adapterOptions
  type: "{Object}"
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 68
  description: The type of the underlying record for this snapshot, as a DS.Model.
  itemtype: property
  name: type
  type: "{DS.Model}"
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 79
  description: The name of the type of the underlying record for this snapshot, as
    a string.
  itemtype: property
  name: modelName
  type: "{String}"
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 90
  description: |-
    Returns the value of an attribute.

    Example

    ```javascript
    // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });
    postSnapshot.attr('author'); // => 'Tomster'
    postSnapshot.attr('title'); // => 'Ember.js rocks'
    ```

    Note: Values are loaded eagerly and cached when the snapshot is created.
  itemtype: method
  name: attr
  params:
  - name: keyName
    description: ''
    type: String
  return:
    description: The attribute value or undefined
    type: Object
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 114
  description: |-
    Returns all attributes and their corresponding values.

    Example

    ```javascript
    // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });
    postSnapshot.attributes(); // => { author: 'Tomster', title: 'Ember.js rocks' }
    ```
  itemtype: method
  name: attributes
  return:
    description: All attributes of the current snapshot
    type: Object
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 131
  description: |-
    Returns all changed attributes and their old and new values.

    Example

    ```javascript
    // store.push('post', { id: 1, author: 'Tomster', title: 'Ember.js rocks' });
    postModel.set('title', 'Ember.js rocks!');
    postSnapshot.changedAttributes(); // => { title: ['Ember.js rocks', 'Ember.js rocks!'] }
    ```
  itemtype: method
  name: changedAttributes
  return:
    description: All changed attributes of the current snapshot
    type: Object
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 157
  description: |-
    Returns the current value of a belongsTo relationship.

    `belongsTo` takes an optional hash of options as a second parameter,
    currently supported options are:

    - `id`: set to `true` if you only want the ID of the related record to be
    returned.

    Example

    ```javascript
    // store.push('post', { id: 1, title: 'Hello World' });
    // store.createRecord('comment', { body: 'Lorem ipsum', post: post });
    commentSnapshot.belongsTo('post'); // => DS.Snapshot
    commentSnapshot.belongsTo('post', { id: true }); // => '1'

    // store.push('comment', { id: 1, body: 'Lorem ipsum' });
    commentSnapshot.belongsTo('post'); // => undefined
    ```

    Calling `belongsTo` will return a new Snapshot as long as there's any known
    data for the relationship available, such as an ID. If the relationship is
    known but unset, `belongsTo` will return `null`. If the contents of the
    relationship is unknown `belongsTo` will return `undefined`.

    Note: Relationships are loaded lazily and cached upon first access.
  itemtype: method
  name: belongsTo
  params:
  - name: keyName
    description: ''
    type: String
  - name: options
    description: ''
    type: Object
    optional: true
  return:
    description: |-
      A snapshot or ID of a known
      relationship or null if the relationship is known but unset. undefined
      will be returned if the contents of the relationship is unknown.
    type: "(DS.Snapshot|String|null|undefined)"
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 234
  description: |-
    Returns the current value of a hasMany relationship.

    `hasMany` takes an optional hash of options as a second parameter,
    currently supported options are:

    - `ids`: set to `true` if you only want the IDs of the related records to be
    returned.

    Example

    ```javascript
    // store.push('post', { id: 1, title: 'Hello World', comments: [2, 3] });
    postSnapshot.hasMany('comments'); // => [DS.Snapshot, DS.Snapshot]
    postSnapshot.hasMany('comments', { ids: true }); // => ['2', '3']

    // store.push('post', { id: 1, title: 'Hello World' });
    postSnapshot.hasMany('comments'); // => undefined
    ```

    Note: Relationships are loaded lazily and cached upon first access.
  itemtype: method
  name: hasMany
  params:
  - name: keyName
    description: ''
    type: String
  - name: options
    description: ''
    type: Object
    optional: true
  return:
    description: |-
      An array of snapshots or IDs of a known
      relationship or an empty array if the relationship is known but unset.
      undefined will be returned if the contents of the relationship is unknown.
    type: "(Array|undefined)"
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 306
  description: |-
    Iterates through all the attributes of the model, calling the passed
    function on each attribute.

    Example

    ```javascript
    snapshot.eachAttribute(function(name, meta) {
      // ...
    });
    ```
  itemtype: method
  name: eachAttribute
  params:
  - name: callback
    description: the callback to execute
    type: Function
  - name: binding
    description: the value to which the callback's `this` should be bound
    type: Object
    optional: true
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 326
  description: |-
    Iterates through all the relationships of the model, calling the passed
    function on each relationship.

    Example

    ```javascript
    snapshot.eachRelationship(function(name, relationship) {
      // ...
    });
    ```
  itemtype: method
  name: eachRelationship
  params:
  - name: callback
    description: the callback to execute
    type: Function
  - name: binding
    description: the value to which the callback's `this` should be bound
    type: Object
    optional: true
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/snapshot.js
  line: 346
  description: |-
    Serializes the snapshot using the serializer for the model.

    Example

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      createRecord(store, type, snapshot) {
        var data = snapshot.serialize({ includeId: true });
        var url = `/${type.modelName}`;

        return fetch(url, {
          method: 'POST',
          body: data,
        }).then((response) => response.json())
      }
    });
    ```
  itemtype: method
  name: serialize
  params:
  - name: options
    description: ''
    type: Object
  return:
    description: an object whose values are primitive JSON values only
    type: Object
  class: DS.Snapshot
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 209
  itemtype: method
  name: init
  access: private
  tagname: ''
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 245
  description: |-
    The default adapter to use to communicate to a backend server or
    other persistence layer. This will be overridden by an application
    adapter if present.

    If you want to specify `app/adapters/custom.js` as a string, do:

    ```js
    import DS from 'ember-data';

    export default DS.Store.extend({
      adapter: 'custom',
    });
    ```
  itemtype: property
  name: adapter
  default: "'-json-api'"
  type: "{String}"
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 266
  description: |-
    Returns a JSON representation of the record using a custom
    type-specific serializer, if one exists.

    The available options are:

    * `includeId`: `true` if the record's ID should be included in
      the JSON representation
  itemtype: method
  name: serialize
  access: private
  tagname: ''
  deprecated: true
  params:
  - name: record
    description: the record to serialize
    type: DS.Model
  - name: options
    description: an options hash
    type: Object
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 292
  description: |-
    This property returns the adapter, after resolving a possible
    string key.

    If the supplied `adapter` was a class, or a String property
    path resolved to a class, this property will instantiate the
    class.

    This property is cacheable, so the same instance of a specified
    adapter class should be used for the lifetime of the store.
  itemtype: property
  name: defaultAdapter
  access: private
  tagname: ''
  return:
    description: DS.Adapter
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 319
  description: |-
    Create a new record in the current store. The properties passed
    to this method are set on the newly created record.

    To create a new instance of a `Post`:

    ```js
    store.createRecord('post', {
      title: 'Rails is omakase'
    });
    ```

    To create a new instance of a `Post` that has a relationship with a `User` record:

    ```js
    let user = this.store.peekRecord('user', 1);
    store.createRecord('post', {
      title: 'Rails is omakase',
      user: user
    });
    ```
  itemtype: method
  name: createRecord
  params:
  - name: modelName
    description: ''
    type: String
  - name: inputProperties
    description: |-
      a hash of properties to set on the
        newly created record.
    type: Object
  return:
    description: record
    type: DS.Model
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 385
  description: |-
    If possible, this method asks the adapter to generate an ID for
    a newly created record.
  itemtype: method
  name: _generateId
  access: private
  tagname: ''
  params:
  - name: modelName
    description: ''
    type: String
  - name: properties
    description: from the new record
    type: Object
  return:
    description: if the adapter can generate one, an ID
    type: String
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 410
  description: |-
    For symmetry, a record can be deleted via the store.

    Example

    ```javascript
    let post = store.createRecord('post', {
      title: 'Rails is omakase'
    });

    store.deleteRecord(post);
    ```
  itemtype: method
  name: deleteRecord
  params:
  - name: record
    description: ''
    type: DS.Model
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 430
  description: |-
    For symmetry, a record can be unloaded via the store.
    This will cause the record to be destroyed and freed up for garbage collection.

    Example

    ```javascript
    store.findRecord('post', 1).then(function(post) {
      store.unloadRecord(post);
    });
    ```
  itemtype: method
  name: unloadRecord
  params:
  - name: record
    description: ''
    type: DS.Model
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 453
  itemtype: method
  name: find
  params:
  - name: modelName
    description: ''
    type: String
  - name: id
    description: ''
    type: String|Integer
  - name: options
    description: ''
    type: Object
  return:
    description: promise
    type: Promise
  access: private
  tagname: ''
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 477
  description: |-
    This method returns a record for a given type and id combination.

    The `findRecord` method will always resolve its promise with the same
    object for a given type and `id`.

    The `findRecord` method will always return a **promise** that will be
    resolved with the record.

    Example

    ```app/routes/post.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      model(params) {
        return this.store.findRecord('post', params.post_id);
      }
    });
    ```

    If the record is not yet available, the store will ask the adapter's `find`
    method to find the necessary data. If the record is already present in the
    store, it depends on the reload behavior _when_ the returned promise
    resolves.

    ### Preloading

    You can optionally `preload` specific attributes and relationships that you know of
    by passing them via the passed `options`.

    For example, if your Ember route looks like `/posts/1/comments/2` and your API route
    for the comment also looks like `/posts/1/comments/2` if you want to fetch the comment
    without fetching the post you can pass in the post to the `findRecord` call:

    ```javascript
    store.findRecord('comment', 2, { preload: { post: 1 } });
    ```

    If you have access to the post model you can also pass the model itself:

    ```javascript
    store.findRecord('post', 1).then(function (myPostModel) {
      store.findRecord('comment', 2, { post: myPostModel });
    });
    ```

    ### Reloading

    The reload behavior is configured either via the passed `options` hash or
    the result of the adapter's `shouldReloadRecord`.

    If `{ reload: true }` is passed or `adapter.shouldReloadRecord` evaluates
    to `true`, then the returned promise resolves once the adapter returns
    data, regardless if the requested record is already in the store:

    ```js
    store.push({
      data: {
        id: 1,
        type: 'post',
        revision: 1
      }
    });

    // adapter#findRecord resolves with
    // [
    //   {
    //     id: 1,
    //     type: 'post',
    //     revision: 2
    //   }
    // ]
    store.findRecord('post', 1, { reload: true }).then(function(post) {
      post.get('revision'); // 2
    });
    ```

    If no reload is indicated via the abovementioned ways, then the promise
    immediately resolves with the cached version in the store.

    ### Background Reloading

    Optionally, if `adapter.shouldBackgroundReloadRecord` evaluates to `true`,
    then a background reload is started, which updates the records' data, once
    it is available:

    ```js
    // app/adapters/post.js
    import ApplicationAdapter from "./application";

    export default ApplicationAdapter.extend({
      shouldReloadRecord(store, snapshot) {
        return false;
      },

      shouldBackgroundReloadRecord(store, snapshot) {
        return true;
      }
    });

    // ...

    store.push({
      data: {
        id: 1,
        type: 'post',
        revision: 1
      }
    });

    let blogPost = store.findRecord('post', 1).then(function(post) {
      post.get('revision'); // 1
    });

    // later, once adapter#findRecord resolved with
    // [
    //   {
    //     id: 1,
    //     type: 'post',
    //     revision: 2
    //   }
    // ]

    blogPost.get('revision'); // 2
    ```

    If you would like to force or prevent background reloading, you can set a
    boolean value for `backgroundReload` in the options object for
    `findRecord`.

    ```app/routes/post/edit.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      model(params) {
        return this.store.findRecord('post', params.post_id, { backgroundReload: false });
      }
    });
    ```

       If you pass an object on the `adapterOptions` property of the options
       argument it will be passed to you adapter via the snapshot

    ```app/routes/post/edit.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      model(params) {
        return this.store.findRecord('post', params.post_id, {
          adapterOptions: { subscribe: false }
        });
      }
    });
    ```

    ```app/adapters/post.js
    import MyCustomAdapter from './custom-adapter';

    export default MyCustomAdapter.extend({
      findRecord(store, type, id, snapshot) {
        if (snapshot.adapterOptions.subscribe) {
          // ...
        }
        // ...
      }
    });
    ```

    See [peekRecord](#method_peekRecord) to get the cached version of a record.

    ### Retrieving Related Model Records

    If you use an adapter such as Ember's default
    [`JSONAPIAdapter`](http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html)
    that supports the [JSON API specification](http://jsonapi.org/) and if your server
    endpoint supports the use of an
    ['include' query parameter](http://jsonapi.org/format/#fetching-includes),
    you can use `findRecord()` to automatically retrieve additional records related to
    the one you request by supplying an `include` parameter in the `options` object.

    For example, given a `post` model that has a `hasMany` relationship with a `comment`
    model, when we retrieve a specific post we can have the server also return that post's
    comments in the same request:

    ```app/routes/post.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      model(params) {
       return this.store.findRecord('post', params.post_id, { include: 'comments' });
      }
    });

    ```
    In this case, the post's comments would then be available in your template as
    `model.comments`.

    Multiple relationships can be requested using an `include` parameter consisting of a
    comma-separated list (without white-space) while nested relationships can be specified
    using a dot-separated sequence of relationship names. So to request both the post's
    comments and the authors of those comments the request would look like this:

    ```app/routes/post.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      model(params) {
       return this.store.findRecord('post', params.post_id, { include: 'comments,comments.author' });
      }
    });

    ```
  since: 1.13.0
  itemtype: method
  name: findRecord
  params:
  - name: modelName
    description: ''
    type: String
  - name: id
    description: ''
    type: "(String|Integer)"
  - name: options
    description: ''
    type: Object
  return:
    description: promise
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 767
  description: |-
    This method makes a series of requests to the adapter's `find` method
    and returns a promise that resolves once they are all loaded.
  access: private
  tagname: ''
  itemtype: method
  name: findByIds
  params:
  - name: modelName
    description: ''
    type: String
  - name: ids
    description: ''
    type: Array
  return:
    description: promise
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 792
  description: |-
    This method is called by `findRecord` if it discovers that a particular
    type/id pair hasn't been loaded yet to kick off a request to the
    adapter.
  itemtype: method
  name: _fetchRecord
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: model
    type: InternalModel
  return:
    description: promise
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 977
  description: |-
    Get the reference for the specified record.

    Example

    ```javascript
    let userRef = store.getReference('user', 1);

    // check if the user is loaded
    let isLoaded = userRef.value() !== null;

    // get the record of the reference (null if not yet available)
    let user = userRef.value();

    // get the identifier of the reference
    if (userRef.remoteType() === 'id') {
    let id = userRef.id();
    }

    // load user (via store.find)
    userRef.load().then(...)

    // or trigger a reload
    userRef.reload().then(...)

    // provide data for reference
    userRef.push({ id: 1, username: '@user' }).then(function(user) {
      userRef.value() === user;
    });
    ```
  itemtype: method
  name: getReference
  params:
  - name: modelName
    description: ''
    type: String
  - name: id
    description: ''
    type: String|Integer
  since: 2.5.0
  return:
    description: ''
    type: RecordReference
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1020
  description: |-
    Get a record by a given type and ID without triggering a fetch.

    This method will synchronously return the record if it is available in the store,
    otherwise it will return `null`. A record is available if it has been fetched earlier, or
    pushed manually into the store.

    _Note: This is a synchronous method and does not return a promise._

    ```js
    let post = store.peekRecord('post', 1);

    post.get('id'); // 1
    ```
  since: 1.13.0
  itemtype: method
  name: peekRecord
  params:
  - name: modelName
    description: ''
    type: String
  - name: id
    description: ''
    type: String|Integer
  return:
    description: record
    type: DS.Model|null
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1054
  description: |-
    This method is called by the record's `reload` method.

    This method calls the adapter's `find` method, which returns a promise. When
    **that** promise resolves, `reloadRecord` will resolve the promise returned
    by the record's `reload`.
  itemtype: method
  name: reloadRecord
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: ''
    type: DS.Model
  return:
    description: promise
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1077
  description: |-
    This method returns true if a record for a given modelName and id is already
    loaded in the store. Use this function to know beforehand if a findRecord()
    will result in a request or that it will be a cache hit.

    Example

    ```javascript
    store.hasRecordForId('post', 1); // false
    store.findRecord('post', 1).then(function() {
      store.hasRecordForId('post', 1); // true
    });
    ```
  itemtype: method
  name: hasRecordForId
  params:
  - name: modelName
    description: ''
    type: String
  - name: id
    description: ''
    type: "(String|Integer)"
  return:
    description: ''
    type: Boolean
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1108
  description: |-
    Returns id record for a given type and ID. If one isn't already loaded,
    it builds a new record and leaves it in the `empty` state.
  itemtype: method
  name: recordForId
  access: private
  tagname: ''
  params:
  - name: modelName
    description: ''
    type: String
  - name: id
    description: ''
    type: "(String|Integer)"
  return:
    description: record
    type: DS.Model
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1139
  itemtype: method
  name: findMany
  access: private
  tagname: ''
  params:
  - name: internalModels
    description: ''
    type: Array
  return:
    description: promise
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1156
  description: |-
    If a relationship was originally populated by the adapter as a link
    (as opposed to a list of IDs), this method is called when the
    relationship is fetched.

    The link (which is usually a URL) is passed through unchanged, so the
    adapter can make whatever request it wants.

    The usual use-case is for the server to register a URL as a link, and
    then use that URL in the future to make a request for the relationship.
  itemtype: method
  name: findHasMany
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: ''
    type: InternalModel
  - name: link
    description: ''
    type: Any
  - name: relationship
    description: ''
    type: "(Relationship)"
  return:
    description: promise
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1183
  itemtype: method
  name: findBelongsTo
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: ''
    type: InternalModel
  - name: link
    description: ''
    type: Any
  - name: relationship
    description: ''
    type: Relationship
  return:
    description: promise
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1200
  description: |-
    This method delegates a query to the adapter. This is the one place where
    adapter-level semantics are exposed to the application.

    Each time this method is called a new request is made through the adapter.

    Exposing queries this way seems preferable to creating an abstract query
    language for all server-side queries, and then require all adapters to
    implement them.

    ---

    If you do something like this:

    ```javascript
    store.query('person', { page: 1 });
    ```

    The call made to the server, using a Rails backend, will look something like this:

    ```
    Started GET "/api/v1/person?page=1"
    Processing by Api::V1::PersonsController#index as HTML
    Parameters: { "page"=>"1" }
    ```

    ---

    If you do something like this:

    ```javascript
    store.query('person', { ids: [1, 2, 3] });
    ```

    The call to the server, using a Rails backend, will look something like this:

    ```
    Started GET "/api/v1/person?ids%5B%5D=1&ids%5B%5D=2&ids%5B%5D=3"
    Processing by Api::V1::PersonsController#index as HTML
    Parameters: { "ids" => ["1", "2", "3"] }
    ```

    This method returns a promise, which is resolved with an
    [`AdapterPopulatedRecordArray`](http://emberjs.com/api/data/classes/DS.AdapterPopulatedRecordArray.html)
    once the server returns.
  since: 1.13.0
  itemtype: method
  name: query
  params:
  - name: modelName
    description: ''
    type: String
  - name: query
    description: an opaque query to be used by the adapter
    type: Any
  return:
    description: promise
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1286
  description: |-
    This method makes a request for one record, where the `id` is not known
    beforehand (if the `id` is known, use [`findRecord`](#method_findRecord)
    instead).

    This method can be used when it is certain that the server will return a
    single object for the primary data.

    Let's assume our API provides an endpoint for the currently logged in user
    via:

    ```
    // GET /api/current_user
    {
      user: {
        id: 1234,
        username: 'admin'
      }
    }
    ```

    Since the specific `id` of the `user` is not known beforehand, we can use
    `queryRecord` to get the user:

    ```javascript
    store.queryRecord('user', {}).then(function(user) {
      let username = user.get('username');
      console.log(`Currently logged in as ${username}`);
    });
    ```

    The request is made through the adapters' `queryRecord`:

    ```app/adapters/user.js
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      queryRecord(modelName, query) {
        return Ember.$.getJSON('/api/current_user');
      }
    });
    ```

    Note: the primary use case for `store.queryRecord` is when a single record
    is queried and the `id` is not known beforehand. In all other cases
    `store.query` and using the first item of the array is likely the preferred
    way:

    ```
    // GET /users?username=unique
    {
      data: [{
        id: 1234,
        type: 'user',
        attributes: {
          username: "unique"
        }
      }]
    }
    ```

    ```javascript
    store.query('user', { username: 'unique' }).then(function(users) {
      return users.get('firstObject');
    }).then(function(user) {
      let id = user.get('id');
    });
    ```

    This method returns a promise, which resolves with the found record.

    If the adapter returns no data for the primary data of the payload, then
    `queryRecord` resolves with `null`:

    ```
    // GET /users?username=unique
    {
      data: null
    }
    ```

    ```javascript
    store.queryRecord('user', { username: 'unique' }).then(function(user) {
      console.log(user); // null
    });
    ```
  since: 1.13.0
  itemtype: method
  name: queryRecord
  params:
  - name: modelName
    description: ''
    type: String
  - name: query
    description: an opaque query to be used by the adapter
    type: Any
  return:
    description: promise which resolves with the found record or `null`
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1402
  description: |-
    `findAll` asks the adapter's `findAll` method to find the records for the
    given type, and returns a promise which will resolve with all records of
    this type present in the store, even if the adapter only returns a subset
    of them.

    ```app/routes/authors.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      model(params) {
        return this.store.findAll('author');
      }
    });
    ```

    _When_ the returned promise resolves depends on the reload behavior,
    configured via the passed `options` hash and the result of the adapter's
    `shouldReloadAll` method.

    ### Reloading

    If `{ reload: true }` is passed or `adapter.shouldReloadAll` evaluates to
    `true`, then the returned promise resolves once the adapter returns data,
    regardless if there are already records in the store:

    ```js
    store.push({
      data: {
        id: 'first',
        type: 'author'
      }
    });

    // adapter#findAll resolves with
    // [
    //   {
    //     id: 'second',
    //     type: 'author'
    //   }
    // ]
    store.findAll('author', { reload: true }).then(function(authors) {
      authors.getEach('id'); // ['first', 'second']
    });
    ```

    If no reload is indicated via the abovementioned ways, then the promise
    immediately resolves with all the records currently loaded in the store.

    ### Background Reloading

    Optionally, if `adapter.shouldBackgroundReloadAll` evaluates to `true`,
    then a background reload is started. Once this resolves, the array with
    which the promise resolves, is updated automatically so it contains all the
    records in the store:

    ```js
    // app/adapters/application.js
    export default DS.Adapter.extend({
      shouldReloadAll(store, snapshotsArray) {
        return false;
      },

      shouldBackgroundReloadAll(store, snapshotsArray) {
        return true;
      }
    });

    // ...

    store.push({
      data: {
        id: 'first',
        type: 'author'
      }
    });

    let allAuthors;
    store.findAll('author').then(function(authors) {
      authors.getEach('id'); // ['first']

      allAuthors = authors;
    });

    // later, once adapter#findAll resolved with
    // [
    //   {
    //     id: 'second',
    //     type: 'author'
    //   }
    // ]

    allAuthors.getEach('id'); // ['first', 'second']
    ```

    If you would like to force or prevent background reloading, you can set a
    boolean value for `backgroundReload` in the options object for
    `findAll`.

    ```app/routes/post/edit.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      model() {
        return this.store.findAll('post', { backgroundReload: false });
      }
    });
    ```

    If you pass an object on the `adapterOptions` property of the options
    argument it will be passed to you adapter via the `snapshotRecordArray`

    ```app/routes/posts.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      model(params) {
        return this.store.findAll('post', {
          adapterOptions: { subscribe: false }
        });
      }
    });
    ```

    ```app/adapters/post.js
    import MyCustomAdapter from './custom-adapter';

    export default MyCustomAdapter.extend({
      findAll(store, type, sinceToken, snapshotRecordArray) {
        if (snapshotRecordArray.adapterOptions.subscribe) {
          // ...
        }
        // ...
      }
    });
    ```

    See [peekAll](#method_peekAll) to get an array of current records in the
    store, without waiting until a reload is finished.

    ### Retrieving Related Model Records

    If you use an adapter such as Ember's default
    [`JSONAPIAdapter`](http://emberjs.com/api/data/classes/DS.JSONAPIAdapter.html)
    that supports the [JSON API specification](http://jsonapi.org/) and if your server
    endpoint supports the use of an
    ['include' query parameter](http://jsonapi.org/format/#fetching-includes),
    you can use `findAll()` to automatically retrieve additional records related to
    those requested by supplying an `include` parameter in the `options` object.

    For example, given a `post` model that has a `hasMany` relationship with a `comment`
    model, when we retrieve all of the post records we can have the server also return
    all of the posts' comments in the same request:

    ```app/routes/posts.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      model() {
       return this.store.findAll('post', { include: 'comments' });
      }
    });

    ```
    Multiple relationships can be requested using an `include` parameter consisting of a
    comma-separated list (without white-space) while nested relationships can be specified
    using a dot-separated sequence of relationship names. So to request both the posts'
    comments and the authors of those comments the request would look like this:

    ```app/routes/posts.js
    import Ember from 'ember';

    export default Ember.Route.extend({
      model() {
       return this.store.findAll('post', { include: 'comments,comments.author' });
      }
    });

    ```

    See [query](#method_query) to only get a subset of records from the server.
  since: 1.13.0
  itemtype: method
  name: findAll
  params:
  - name: modelName
    description: ''
    type: String
  - name: options
    description: ''
    type: Object
  return:
    description: promise
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1605
  itemtype: method
  name: _fetchAll
  access: private
  tagname: ''
  params:
  - name: modelName
    description: ''
    type: DS.Model
  - name: array
    description: ''
    type: DS.RecordArray
  return:
    description: promise
    type: Promise
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1643
  itemtype: method
  name: didUpdateAll
  params:
  - name: modelName
    description: ''
    type: String
  access: private
  tagname: ''
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1655
  description: |-
    This method returns a filtered array that contains all of the
    known records for a given type in the store.

    Note that because it's just a filter, the result will contain any
    locally created records of the type, however, it will not make a
    request to the backend to retrieve additional records. If you
    would like to request all the records from the backend please use
    [store.findAll](#method_findAll).

    Also note that multiple calls to `peekAll` for a given type will always
    return the same `RecordArray`.

    Example

    ```javascript
    let localPosts = store.peekAll('post');
    ```
  since: 1.13.0
  itemtype: method
  name: peekAll
  params:
  - name: modelName
    description: ''
    type: String
  return:
    description: ''
    type: DS.RecordArray
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1691
  description: |-
    This method unloads all records in the store.
    It schedules unloading to happen during the next run loop.

    Optionally you can pass a type which unload all records for a given type.

    ```javascript
    store.unloadAll();
    store.unloadAll('post');
    ```
  itemtype: method
  name: unloadAll
  params:
  - name: modelName
    description: ''
    type: String
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1716
  description: |-
    Takes a type and filter function, and returns a live RecordArray that
    remains up to date as new records are loaded into the store or created
    locally.

    The filter function takes a materialized record, and returns true
    if the record should be included in the filter and false if it should
    not.

    Example

    ```javascript
    store.filter('post', function(post) {
      return post.get('unread');
    });
    ```

    The filter function is called once on all records for the type when
    it is created, and then once on each newly loaded or created record.

    If any of a record's properties change, or if it changes state, the
    filter function will be invoked again to determine whether it should
    still be in the array.

    Optionally you can pass a query, which is the equivalent of calling
    [query](#method_query) with that same query, to fetch additional records
    from the server. The results returned by the server could then appear
    in the filter if they match the filter function.

    The query itself is not used to filter records, it's only sent to your
    server for you to be able to do server-side filtering. The filter
    function will be applied on the returned results regardless.

    Example

    ```javascript
    store.filter('post', { unread: true }, function(post) {
      return post.get('unread');
    }).then(function(unreadPosts) {
      unreadPosts.get('length'); // 5
      let unreadPost = unreadPosts.objectAt(0);
      unreadPost.set('unread', false);
      unreadPosts.get('length'); // 4
    });
    ```
  itemtype: method
  name: filter
  access: private
  tagname: ''
  params:
  - name: modelName
    description: ''
    type: String
  - name: query
    description: optional query
    type: Object
  - name: filter
    description: ''
    type: Function
  return:
    description: ''
    type: DS.PromiseArray
  deprecated: true
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1803
  description: |-
    This method has been deprecated and is an alias for store.hasRecordForId, which should
    be used instead.
  deprecated: true
  itemtype: method
  name: recordIsLoaded
  params:
  - name: modelName
    description: ''
    type: String
  - name: id
    description: ''
    type: String
  return:
    description: ''
    type: Boolean
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1826
  description: |-
    This method is called by `record.save`, and gets passed a
    resolver for the promise that `record.save` returns.

    It schedules saving to happen at the end of the run loop.
  itemtype: method
  name: scheduleSave
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: ''
    type: InternalModel
  - name: resolver
    description: ''
    type: Resolver
  - name: options
    description: ''
    type: Object
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1849
  description: |-
    This method is called at the end of the run loop, and
    flushes any records passed into `scheduleSave`
  itemtype: method
  name: flushPendingSave
  access: private
  tagname: ''
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1883
  description: |-
    This method is called once the promise returned by an
    adapter's `createRecord`, `updateRecord` or `deleteRecord`
    is resolved.

    If the data provides a server-generated ID, it will
    update the record and the store's indexes.
  itemtype: method
  name: didSaveRecord
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: the in-flight internal model
    type: InternalModel
  - name: data
    description: optional data (see above)
    type: Object
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1914
  description: |-
    This method is called once the promise returned by an
    adapter's `createRecord`, `updateRecord` or `deleteRecord`
    is rejected with a `DS.InvalidError`.
  itemtype: method
  name: recordWasInvalid
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: ''
    type: InternalModel
  - name: errors
    description: ''
    type: Object
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1928
  description: |-
    This method is called once the promise returned by an
    adapter's `createRecord`, `updateRecord` or `deleteRecord`
    is rejected (with anything other than a `DS.InvalidError`).
  itemtype: method
  name: recordWasError
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: ''
    type: InternalModel
  - name: error
    description: ''
    type: Error
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1942
  description: |-
    When an adapter's `createRecord`, `updateRecord` or `deleteRecord`
    resolves with data, this method extracts the ID from the supplied
    data.
  itemtype: method
  name: updateId
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: ''
    type: InternalModel
  - name: data
    description: ''
    type: Object
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1975
  description: Returns a map of IDs to client IDs for a given modelName.
  itemtype: method
  name: _internalModelsFor
  access: private
  tagname: ''
  params:
  - name: modelName
    description: ''
    type: String
  return:
    description: recordMap
    type: Object
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 1992
  description: This internal method is used by `push`.
  itemtype: method
  name: _load
  access: private
  tagname: ''
  params:
  - name: data
    description: ''
    type: Object
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 2056
  description: |-
    Returns the model class for the particular `modelName`.

    The class of a model might be useful if you want to get a list of all the
    relationship names of the model, see
    [`relationshipNames`](http://emberjs.com/api/data/classes/DS.Model.html#property_relationshipNames)
    for example.
  itemtype: method
  name: modelFor
  params:
  - name: modelName
    description: ''
    type: String
  return:
    description: ''
    type: DS.Model
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 2133
  description: |-
    Push some data for a given type into the store.

    This method expects normalized [JSON API](http://jsonapi.org/) document. This means you have to follow [JSON API specification](http://jsonapi.org/format/) with few minor adjustments:
    - record's `type` should always be in singular, dasherized form
    - members (properties) should be camelCased

    [Your primary data should be wrapped inside `data` property](http://jsonapi.org/format/#document-top-level):

    ```js
    store.push({
      data: {
        // primary data for single record of type `Person`
        id: '1',
        type: 'person',
        attributes: {
          firstName: 'Daniel',
          lastName: 'Kmak'
        }
      }
    });
    ```

    [Demo.](http://ember-twiddle.com/fb99f18cd3b4d3e2a4c7)

    `data` property can also hold an array (of records):

    ```js
    store.push({
      data: [
        // an array of records
        {
          id: '1',
          type: 'person',
          attributes: {
            firstName: 'Daniel',
            lastName: 'Kmak'
          }
        },
        {
          id: '2',
          type: 'person',
          attributes: {
            firstName: 'Tom',
            lastName: 'Dale'
          }
        }
      ]
    });
    ```

    [Demo.](http://ember-twiddle.com/69cdbeaa3702159dc355)

    There are some typical properties for `JSONAPI` payload:
    * `id` - mandatory, unique record's key
    * `type` - mandatory string which matches `model`'s dasherized name in singular form
    * `attributes` - object which holds data for record attributes - `DS.attr`'s declared in model
    * `relationships` - object which must contain any of the following properties under each relationships' respective key (example path is `relationships.achievements.data`):
      - [`links`](http://jsonapi.org/format/#document-links)
      - [`data`](http://jsonapi.org/format/#document-resource-object-linkage) - place for primary data
      - [`meta`](http://jsonapi.org/format/#document-meta) - object which contains meta-information about relationship

    For this model:

    ```app/models/person.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      firstName: DS.attr('string'),
      lastName: DS.attr('string'),

      children: DS.hasMany('person')
    });
    ```

    To represent the children as IDs:

    ```js
    {
      data: {
        id: '1',
        type: 'person',
        attributes: {
          firstName: 'Tom',
          lastName: 'Dale'
        },
        relationships: {
          children: {
            data: [
              {
                id: '2',
                type: 'person'
              },
              {
                id: '3',
                type: 'person'
              },
              {
                id: '4',
                type: 'person'
              }
            ]
          }
        }
      }
    }
    ```

    [Demo.](http://ember-twiddle.com/343e1735e034091f5bde)

    To represent the children relationship as a URL:

    ```js
    {
      data: {
        id: '1',
        type: 'person',
        attributes: {
          firstName: 'Tom',
          lastName: 'Dale'
        },
        relationships: {
          children: {
            links: {
              related: '/people/1/children'
            }
          }
        }
      }
    }
    ```

    If you're streaming data or implementing an adapter, make sure
    that you have converted the incoming data into this form. The
    store's [normalize](#method_normalize) method is a convenience
    helper for converting a json payload into the form Ember Data
    expects.

    ```js
    store.push(store.normalize('person', data));
    ```

    This method can be used both to push in brand new
    records, as well as to update existing records.
  itemtype: method
  name: push
  params:
  - name: data
    description: ''
    type: Object
  return:
    description: |-
      the record(s) that was created or
        updated.
    type: DS.Model|Array
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 2420
  description: |-
    Push some raw data into the store.

    This method can be used both to push in brand new
    records, as well as to update existing records. You
    can push in more than one type of object at once.
    All objects should be in the format expected by the
    serializer.

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.ActiveModelSerializer;
    ```

    ```js
    let pushData = {
      posts: [
        { id: 1, post_title: "Great post", comment_ids: [2] }
      ],
      comments: [
        { id: 2, comment_body: "Insightful comment" }
      ]
    }

    store.pushPayload(pushData);
    ```

    By default, the data will be deserialized using a default
    serializer (the application serializer if it exists).

    Alternatively, `pushPayload` will accept a model type which
    will determine which serializer will process the payload.

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.ActiveModelSerializer;
    ```

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.JSONSerializer;
    ```

    ```js
    store.pushPayload('comment', pushData); // Will use the application serializer
    store.pushPayload('post', pushData); // Will use the post serializer
    ```
  itemtype: method
  name: pushPayload
  params:
  - name: modelName
    description: Optionally, a model type used to determine which serializer will
      be used
    type: String
  - name: inputPayload
    description: ''
    type: Object
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 2495
  description: |-
    `normalize` converts a json payload into the normalized form that
    [push](#method_push) expects.

    Example

    ```js
    socket.on('message', function(message) {
      let modelName = message.model;
      let data = message.data;
      store.push(store.normalize(modelName, data));
    });
    ```
  itemtype: method
  name: normalize
  params:
  - name: modelName
    description: The name of the model type for this payload
    type: String
  - name: payload
    description: ''
    type: Object
  return:
    description: The normalized payload
    type: Object
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 2524
  description: |-
    Build a brand new record for a given type, ID, and
    initial data.
  itemtype: method
  name: buildRecord
  access: private
  tagname: ''
  params:
  - name: modelName
    description: ''
    type: String
  - name: id
    description: ''
    type: String
  - name: data
    description: ''
    type: Object
  return:
    description: internal model
    type: InternalModel
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 2562
  description: |-
    When a record is destroyed, this un-indexes it and
    removes it from any record arrays so it can be GCed.
  itemtype: method
  name: _removeFromIdMap
  access: private
  tagname: ''
  params:
  - name: internalModel
    description: ''
    type: InternalModel
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 2581
  description: |-
    Returns an instance of the adapter for a given type. For
    example, `adapterFor('person')` will return an instance of
    `App.PersonAdapter`.

    If no `App.PersonAdapter` is found, this method will look
    for an `App.ApplicationAdapter` (the default adapter for
    your entire application).

    If no `App.ApplicationAdapter` is found, it will return
    the value of the `defaultAdapter`.
  itemtype: method
  name: adapterFor
  access: public
  tagname: ''
  params:
  - name: modelName
    description: ''
    type: String
  return:
    description: DS.Adapter
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/system/store.js
  line: 2611
  description: |-
    Returns an instance of the serializer for a given type. For
    example, `serializerFor('person')` will return an instance of
    `App.PersonSerializer`.

    If no `App.PersonSerializer` is found, this method will look
    for an `App.ApplicationSerializer` (the default serializer for
    your entire application).

    if no `App.ApplicationSerializer` is found, it will attempt
    to get the `defaultSerializer` from the `PersonAdapter`
    (`adapterFor('person')`).

    If a serializer cannot be found on the adapter, it will fall back
    to an instance of `DS.JSONSerializer`.
  itemtype: method
  name: serializerFor
  access: public
  tagname: ''
  params:
  - name: modelName
    description: the record to serialize
    type: String
  return:
    description: ''
    type: DS.Serializer
  class: DS.Store
  module: ember-data
  namespace: DS
- file: addon/-private/core.js
  line: 15
  itemtype: property
  name: VERSION
  type: String
  static: 1
  class: DS
  module: ember-data
- file: addon/adapters/errors.js
  line: 341
  description: |-
    Convert an hash of errors into an array with errors in JSON-API format.

    ```javascript
    import DS from 'ember-data';

    const { errorsHashToArray } = DS;

    let errors = {
      base: 'Invalid attributes on saving this record',
      name: 'Must be present',
      age: ['Must be present', 'Must be a number']
    };

    let errorsArray = errorsHashToArray(errors);
    // [
    //   {
    //     title: "Invalid Document",
    //     detail: "Invalid attributes on saving this record",
    //     source: { pointer: "/data" }
    //   },
    //   {
    //     title: "Invalid Attribute",
    //     detail: "Must be present",
    //     source: { pointer: "/data/attributes/name" }
    //   },
    //   {
    //     title: "Invalid Attribute",
    //     detail: "Must be present",
    //     source: { pointer: "/data/attributes/age" }
    //   },
    //   {
    //     title: "Invalid Attribute",
    //     detail: "Must be a number",
    //     source: { pointer: "/data/attributes/age" }
    //   }
    // ]
    ```
  itemtype: method
  name: errorsHashToArray
  access: public
  tagname: ''
  params:
  - name: errors
    description: hash with errors as properties
    type: Object
  return:
    description: array of errors in JSON-API format
    type: Array
  class: DS
  module: ember-data
- file: addon/adapters/errors.js
  line: 414
  description: |-
    Convert an array of errors in JSON-API format into an object.

    ```javascript
    import DS from 'ember-data';

    const { errorsArrayToHash } = DS;

    let errorsArray = [
      {
        title: 'Invalid Attribute',
        detail: 'Must be present',
        source: { pointer: '/data/attributes/name' }
      },
      {
        title: 'Invalid Attribute',
        detail: 'Must be present',
        source: { pointer: '/data/attributes/age' }
      },
      {
        title: 'Invalid Attribute',
        detail: 'Must be a number',
        source: { pointer: '/data/attributes/age' }
      }
    ];

    let errors = errorsArrayToHash(errorsArray);
    // {
    //   "name": ["Must be present"],
    //   "age":  ["Must be present", "must be a number"]
    // }
    ```
  itemtype: method
  name: errorsArrayToHash
  access: public
  tagname: ''
  params:
  - name: errors
    description: array of errors in JSON-API format
    type: Array
  return:
    description: ''
    type: Object
  class: DS
  module: ember-data
- file: addon/adapters/json-api.js
  line: 150
  itemtype: method
  name: ajaxOptions
  access: private
  tagname: ''
  params:
  - name: url
    description: ''
    type: String
  - name: type
    description: The request type GET, POST, PUT, DELETE etc.
    type: String
  - name: options
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  class: DS.JSONAPIAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/json-api.js
  line: 192
  description: |-
    By default the JSONAPIAdapter will send each find request coming from a `store.find`
    or from accessing a relationship separately to the server. If your server supports passing
    ids as a query string, you can set coalesceFindRequests to true to coalesce all find requests
    within a single runloop.

    For example, if you have an initial payload of:

    ```javascript
    {
      data: {
        id: 1,
        type: 'post',
        relationship: {
          comments: {
            data: [
              { id: 1, type: 'comment' },
              { id: 2, type: 'comment' }
            ]
          }
        }
      }
    }
    ```

    By default calling `post.get('comments')` will trigger the following requests(assuming the
    comments haven't been loaded before):

    ```
    GET /comments/1
    GET /comments/2
    ```

    If you set coalesceFindRequests to `true` it will instead trigger the following request:

    ```
    GET /comments?filter[id]=1,2
    ```

    Setting coalesceFindRequests to `true` also works for `store.find` requests and `belongsTo`
    relationships accessed within the same runloop. If you set `coalesceFindRequests: true`

    ```javascript
    store.findRecord('comment', 1);
    store.findRecord('comment', 2);
    ```

    will also send a request to: `GET /comments?filter[id]=1,2`

    Note: Requests coalescing rely on URL building strategy. So if you override `buildURL` in your app
    `groupRecordsForFindMany` more likely should be overridden as well in order for coalescing to work.
  itemtype: property
  name: coalesceFindRequests
  type: "{boolean}"
  class: DS.JSONAPIAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 289
  description: |-
    By default, the RESTAdapter will send the query params sorted alphabetically to the
    server.

    For example:

    ```js
    store.query('posts', { sort: 'price', category: 'pets' });
    ```

    will generate a requests like this `/posts?category=pets&sort=price`, even if the
    parameters were specified in a different order.

    That way the generated URL will be deterministic and that simplifies caching mechanisms
    in the backend.

    Setting `sortQueryParams` to a falsey value will respect the original order.

    In case you want to sort the query parameters with a different criteria, set
    `sortQueryParams` to your custom sort function.

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      sortQueryParams(params) {
        let sortedKeys = Object.keys(params).sort().reverse();
        let len = sortedKeys.length, newParams = {};

        for (let i = 0; i < len; i++) {
          newParams[sortedKeys[i]] = params[sortedKeys[i]];
        }

        return newParams;
      }
    });
    ```
  itemtype: method
  name: sortQueryParams
  params:
  - name: obj
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 346
  description: |-
    By default the RESTAdapter will send each find request coming from a `store.find`
    or from accessing a relationship separately to the server. If your server supports passing
    ids as a query string, you can set coalesceFindRequests to true to coalesce all find requests
    within a single runloop.

    For example, if you have an initial payload of:

    ```javascript
    {
      post: {
        id: 1,
        comments: [1, 2]
      }
    }
    ```

    By default calling `post.get('comments')` will trigger the following requests(assuming the
    comments haven't been loaded before):

    ```
    GET /comments/1
    GET /comments/2
    ```

    If you set coalesceFindRequests to `true` it will instead trigger the following request:

    ```
    GET /comments?ids[]=1&ids[]=2
    ```

    Setting coalesceFindRequests to `true` also works for `store.find` requests and `belongsTo`
    relationships accessed within the same runloop. If you set `coalesceFindRequests: true`

    ```javascript
    store.findRecord('comment', 1);
    store.findRecord('comment', 2);
    ```

    will also send a request to: `GET /comments?ids[]=1&ids[]=2`

    Note: Requests coalescing rely on URL building strategy. So if you override `buildURL` in your app
    `groupRecordsForFindMany` more likely should be overridden as well in order for coalescing to work.
  itemtype: property
  name: coalesceFindRequests
  type: "{boolean}"
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 395
  description: |-
    Endpoint paths can be prefixed with a `namespace` by setting the namespace
    property on the adapter:

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      namespace: 'api/1'
    });
    ```

    Requests for the `Post` model would now target `/api/1/post/`.
  itemtype: property
  name: namespace
  type: "{String}"
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 413
  description: |-
    An adapter can target other hosts by setting the `host` property.

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      host: 'https://api.example.com'
    });
    ```

    Requests for the `Post` model would now target `https://api.example.com/post/`.
  itemtype: property
  name: host
  type: "{String}"
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 430
  description: |-
    Some APIs require HTTP headers, e.g. to provide an API
    key. Arbitrary headers can be set as key/value pairs on the
    `RESTAdapter`'s `headers` object and Ember Data will send them
    along with each ajax request. For dynamic headers see [headers
    customization](/api/data/classes/DS.RESTAdapter.html#toc_headers-customization).

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.RESTAdapter.extend({
      headers: {
        'API_KEY': 'secret key',
        'ANOTHER_HEADER': 'Some header value'
      }
    });
    ```
  itemtype: property
  name: headers
  type: "{Object}"
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 452
  description: |-
    Called by the store in order to fetch the JSON for a given
    type and ID.

    The `findRecord` method makes an Ajax request to a URL computed by
    `buildURL`, and returns a promise for the resulting payload.

    This method performs an HTTP `GET` request with the id provided as part of the query string.
  since: 1.13.0
  itemtype: method
  name: findRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: id
    description: ''
    type: String
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 485
  description: |-
    Called by the store in order to fetch a JSON array for all
    of the records for a given type.

    The `findAll` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a
    promise for the resulting payload.
  itemtype: method
  name: findAll
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: sinceToken
    description: ''
    type: String
  - name: snapshotRecordArray
    description: ''
    type: DS.SnapshotRecordArray
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 521
  description: |-
    Called by the store in order to fetch a JSON array for
    the records that match a particular query.

    The `query` method makes an Ajax (HTTP GET) request to a URL
    computed by `buildURL`, and returns a promise for the resulting
    payload.

    The `query` argument is a simple JavaScript object that will be passed directly
    to the server as parameters.
  itemtype: method
  name: query
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: query
    description: ''
    type: Object
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 557
  description: |-
    Called by the store in order to fetch a JSON object for
    the record that matches a particular query.

    The `queryRecord` method makes an Ajax (HTTP GET) request to a URL
    computed by `buildURL`, and returns a promise for the resulting
    payload.

    The `query` argument is a simple JavaScript object that will be passed directly
    to the server as parameters.
  since: 1.13.0
  itemtype: method
  name: queryRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: query
    description: ''
    type: Object
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 594
  description: |-
    Called by the store in order to fetch several records together if `coalesceFindRequests` is true

    For example, if the original payload looks like:

    ```js
    {
      "id": 1,
      "title": "Rails is omakase",
      "comments": [ 1, 2, 3 ]
    }
    ```

    The IDs will be passed as a URL-encoded Array of IDs, in this form:

    ```
    ids[]=1&ids[]=2&ids[]=3
    ```

    Many servers, such as Rails and PHP, will automatically convert this URL-encoded array
    into an Array for you on the server-side. If you want to encode the
    IDs, differently, just override this (one-line) method.

    The `findMany` method makes an Ajax (HTTP GET) request to a URL computed by `buildURL`, and returns a
    promise for the resulting payload.
  itemtype: method
  name: findMany
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: ids
    description: ''
    type: Array
  - name: snapshots
    description: ''
    type: Array
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 641
  description: |-
    Called by the store in order to fetch a JSON array for
    the unloaded records in a has-many relationship that were originally
    specified as a URL (inside of `links`).

    For example, if your original payload looks like this:

    ```js
    {
      "post": {
        "id": 1,
        "title": "Rails is omakase",
        "links": { "comments": "/posts/1/comments" }
      }
    }
    ```

    This method will be called with the parent record and `/posts/1/comments`.

    The `findHasMany` method will make an Ajax (HTTP GET) request to the originally specified URL.

    The format of your `links` value will influence the final request URL via the `urlPrefix` method:

    * Links beginning with `//`, `http://`, `https://`, will be used as is, with no further manipulation.

    * Links beginning with a single `/` will have the current adapter's `host` value prepended to it.

    * Links with no beginning `/` will have a parentURL prepended to it, via the current adapter's `buildURL`.
  itemtype: method
  name: findHasMany
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: relationship
    description: meta object describing the relationship
    type: Object
  - name: url
    description: ''
    type: String
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 695
  description: |-
    Called by the store in order to fetch the JSON for the unloaded record in a
    belongs-to relationship that was originally specified as a URL (inside of
    `links`).

    For example, if your original payload looks like this:

    ```js
    {
      "person": {
        "id": 1,
        "name": "Tom Dale",
        "links": { "group": "/people/1/group" }
      }
    }
    ```

    This method will be called with the parent record and `/people/1/group`.

    The `findBelongsTo` method will make an Ajax (HTTP GET) request to the originally specified URL.

    The format of your `links` value will influence the final request URL via the `urlPrefix` method:

    * Links beginning with `//`, `http://`, `https://`, will be used as is, with no further manipulation.

    * Links beginning with a single `/` will have the current adapter's `host` value prepended to it.

    * Links with no beginning `/` will have a parentURL prepended to it, via the current adapter's `buildURL`.
  itemtype: method
  name: findBelongsTo
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: url
    description: ''
    type: String
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 747
  description: |-
    Called by the store when a newly created record is
    saved via the `save` method on a model record instance.

    The `createRecord` method serializes the record and makes an Ajax (HTTP POST) request
    to a URL computed by `buildURL`.

    See `serialize` for information on how to customize the serialized form
    of a record.
  itemtype: method
  name: createRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 782
  description: |-
    Called by the store when an existing record is saved
    via the `save` method on a model record instance.

    The `updateRecord` method serializes the record and makes an Ajax (HTTP PUT) request
    to a URL computed by `buildURL`.

    See `serialize` for information on how to customize the serialized form
    of a record.
  itemtype: method
  name: updateRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 819
  description: |-
    Called by the store when a record is deleted.

    The `deleteRecord` method  makes an Ajax (HTTP DELETE) request to a URL computed by `buildURL`.
  itemtype: method
  name: deleteRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 869
  description: |-
    Organize records into groups, each of which is to be passed to separate
    calls to `findMany`.

    This implementation groups together records that have the same base URL but
    differing ids. For example `/comments/1` and `/comments/2` will be grouped together
    because we know findMany can coalesce them together as `/comments?ids[]=1&ids[]=2`

    It also supports urls where ids are passed as a query param, such as `/comments?id=1`
    but not those where there is more than 1 query param such as `/comments?id=2&name=David`
    Currently only the query param of `id` is supported. If you need to support others, please
    override this or the `_stripIDFromURL` method.

    It does not group records that have differing base urls, such as for example: `/posts/1/comments/2`
    and `/posts/2/comments/3`
  itemtype: method
  name: groupRecordsForFindMany
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: snapshots
    description: ''
    type: Array
  return:
    description: |-
      an array of arrays of records, each of which is to be
                        loaded separately by `findMany`.
    type: Array
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 933
  description: |-
    Takes an ajax response, and returns the json payload or an error.

    By default this hook just returns the json payload passed to it.
    You might want to override it in two cases:

    1. Your API might return useful results in the response headers.
    Response headers are passed in as the second argument.

    2. Your API might return errors as successful responses with status code
    200 and an Errors text or object. You can return a `DS.InvalidError` or a
    `DS.AdapterError` (or a sub class) from this hook and it will automatically
    reject the promise and put your record into the invalid or error state.

    Returning a `DS.InvalidError` from this method will cause the
    record to transition into the `invalid` state and make the
    `errors` object available on the record. When returning an
    `DS.InvalidError` the store will attempt to normalize the error data
    returned from the server using the serializer's `extractErrors`
    method.
  since: 1.13.0
  itemtype: method
  name: handleResponse
  params:
  - name: status
    description: ''
    type: Number
  - name: headers
    description: ''
    type: Object
  - name: payload
    description: ''
    type: Object
  - name: requestData
    description: "- the original request information"
    type: Object
  return:
    description: response
    type: Object | DS.AdapterError
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 992
  description: |-
    Default `handleResponse` implementation uses this hook to decide if the
    response is a success.
  since: 1.13.0
  itemtype: method
  name: isSuccess
  params:
  - name: status
    description: ''
    type: Number
  - name: headers
    description: ''
    type: Object
  - name: payload
    description: ''
    type: Object
  return:
    description: ''
    type: Boolean
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1007
  description: |-
    Default `handleResponse` implementation uses this hook to decide if the
    response is an invalid error.
  since: 1.13.0
  itemtype: method
  name: isInvalid
  params:
  - name: status
    description: ''
    type: Number
  - name: headers
    description: ''
    type: Object
  - name: payload
    description: ''
    type: Object
  return:
    description: ''
    type: Boolean
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1022
  description: |-
    Takes a URL, an HTTP method and a hash of data, and makes an
    HTTP request.

    When the server responds with a payload, Ember Data will call into `extractSingle`
    or `extractArray` (depending on whether the original query was for one record or
    many records).

    By default, `ajax` method has the following behavior:

    * It sets the response `dataType` to `"json"`
    * If the HTTP method is not `"GET"`, it sets the `Content-Type` to be
      `application/json; charset=utf-8`
    * If the HTTP method is not `"GET"`, it stringifies the data passed in. The
      data is the serialized record in the case of a save.
    * Registers success and failure handlers.
  itemtype: method
  name: ajax
  access: private
  tagname: ''
  params:
  - name: url
    description: ''
    type: String
  - name: type
    description: The request type GET, POST, PUT, DELETE etc.
    type: String
  - name: options
    description: ''
    type: Object
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1078
  itemtype: method
  name: _ajaxRequest
  access: private
  tagname: ''
  params:
  - name: options
    description: jQuery ajax options to be used for the ajax request
    type: Object
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1087
  itemtype: method
  name: ajaxOptions
  access: private
  tagname: ''
  params:
  - name: url
    description: ''
    type: String
  - name: type
    description: The request type GET, POST, PUT, DELETE etc.
    type: String
  - name: options
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1133
  itemtype: method
  name: parseErrorResponse
  access: private
  tagname: ''
  params:
  - name: responseText
    description: ''
    type: String
  return:
    description: ''
    type: Object
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1151
  itemtype: method
  name: normalizeErrorResponse
  access: private
  tagname: ''
  params:
  - name: status
    description: ''
    type: Number
  - name: headers
    description: ''
    type: Object
  - name: payload
    description: ''
    type: Object
  return:
    description: errors payload
    type: Array
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1173
  description: |-
    Generates a detailed ("friendly") error message, with plenty
    of information for debugging (good luck!)
  itemtype: method
  name: generatedDetailedMessage
  access: private
  tagname: ''
  params:
  - name: status
    description: ''
    type: Number
  - name: headers
    description: ''
    type: Object
  - name: payload
    description: ''
    type: Object
  - name: requestData
    description: ''
    type: Object
  return:
    description: detailed error message
    type: String
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1243
  description: Get the data (body or query params) for a request.
  access: public
  tagname: ''
  itemtype: method
  name: dataForRequest
  params:
  - name: params
    description: ''
    type: Object
  return:
    description: data
    type: Object
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1301
  description: Get the HTTP method for a request.
  access: public
  tagname: ''
  itemtype: method
  name: methodForRequest
  params:
  - name: params
    description: ''
    type: Object
  return:
    description: HTTP method
    type: String
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1321
  description: Get the URL for a request.
  access: public
  tagname: ''
  itemtype: method
  name: urlForRequest
  params:
  - name: params
    description: ''
    type: Object
  return:
    description: URL
    type: String
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1358
  description: |-
    Get the headers for a request.

    By default the value of the `headers` property of the adapter is
    returned.
  access: public
  tagname: ''
  itemtype: method
  name: headersForRequest
  params:
  - name: params
    description: ''
    type: Object
  return:
    description: headers
    type: Object
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1373
  description: |-
    Get an object which contains all properties for a request which should
    be made.
  access: private
  tagname: ''
  itemtype: method
  name: _requestFor
  params:
  - name: params
    description: ''
    type: Object
  return:
    description: request object
    type: Object
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1391
  description: Convert a request object into a hash which can be passed to `jQuery.ajax`.
  access: private
  tagname: ''
  itemtype: method
  name: _requestToJQueryAjaxHash
  params:
  - name: request
    description: ''
    type: Object
  return:
    description: jQuery ajax hash
    type: Object
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/adapters/rest.js
  line: 1426
  description: Make a request using `jQuery.ajax`.
  access: private
  tagname: ''
  itemtype: method
  name: _makeRequest
  params:
  - name: request
    description: ''
    type: Object
  return:
    description: promise
    type: Promise
  class: DS.RESTAdapter
  module: ember-data
  namespace: DS
- file: addon/serializers/embedded-records-mixin.js
  line: 102
  description: |-
    Normalize the record and recursively normalize/extract all the embedded records
    while pushing them into the store as they are encountered

    A payload with an attr configured for embedded records needs to be extracted:

    ```js
    {
      "post": {
        "id": "1"
        "title": "Rails is omakase",
        "comments": [{
          "id": "1",
          "body": "Rails is unagi"
        }, {
          "id": "2",
          "body": "Omakase O_o"
        }]
      }
    }
    ```
  itemtype: method
  name: normalize
  params:
  - name: typeClass
    description: ''
    type: DS.Model
  - name: hash
    description: to be normalized
    type: Object
  - name: prop
    description: the hash has been referenced by
    type: String
  return:
    description: the normalized hash
    type: Object
  class: DS.EmbeddedRecordsMixin
  module: ember-data
  namespace: DS
- file: addon/serializers/embedded-records-mixin.js
  line: 143
  description: |-
    Serialize `belongsTo` relationship when it is configured as an embedded object.

    This example of an author model belongs to a post model:

    ```js
    Post = DS.Model.extend({
      title:    DS.attr('string'),
      body:     DS.attr('string'),
      author:   DS.belongsTo('author')
    });

    Author = DS.Model.extend({
      name:     DS.attr('string'),
      post:     DS.belongsTo('post')
    });
    ```

    Use a custom (type) serializer for the post model to configure embedded author

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend(DS.EmbeddedRecordsMixin, {
      attrs: {
        author: { embedded: 'always' }
      }
    })
    ```

    A payload with an attribute configured for embedded records can serialize
    the records together under the root attribute's payload:

    ```js
    {
      "post": {
        "id": "1"
        "title": "Rails is omakase",
        "author": {
          "id": "2"
          "name": "dhh"
        }
      }
    }
    ```
  itemtype: method
  name: serializeBelongsTo
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: json
    description: ''
    type: Object
  - name: relationship
    description: ''
    type: Object
  class: DS.EmbeddedRecordsMixin
  module: ember-data
  namespace: DS
- file: addon/serializers/embedded-records-mixin.js
  line: 242
  description: |-
    Serializes `hasMany` relationships when it is configured as embedded objects.

    This example of a post model has many comments:

    ```js
    Post = DS.Model.extend({
      title:    DS.attr('string'),
      body:     DS.attr('string'),
      comments: DS.hasMany('comment')
    });

    Comment = DS.Model.extend({
      body:     DS.attr('string'),
      post:     DS.belongsTo('post')
    });
    ```

    Use a custom (type) serializer for the post model to configure embedded comments

    ```app/serializers/post.js
    import DS from 'ember-data;

    export default DS.RESTSerializer.extend(DS.EmbeddedRecordsMixin, {
      attrs: {
        comments: { embedded: 'always' }
      }
    })
    ```

    A payload with an attribute configured for embedded records can serialize
    the records together under the root attribute's payload:

    ```js
    {
      "post": {
        "id": "1"
        "title": "Rails is omakase",
        "body": "I want this for my ORM, I want that for my template language..."
        "comments": [{
          "id": "1",
          "body": "Rails is unagi"
        }, {
          "id": "2",
          "body": "Omakase O_o"
        }]
      }
    }
    ```

    The attrs options object can use more specific instruction for extracting and
    serializing. When serializing, an option to embed `ids`, `ids-and-types` or `records` can be set.
    When extracting the only option is `records`.

    So `{ embedded: 'always' }` is shorthand for:
    `{ serialize: 'records', deserialize: 'records' }`

    To embed the `ids` for a related object (using a hasMany relationship):

    ```app/serializers/post.js
    import DS from 'ember-data;

    export default DS.RESTSerializer.extend(DS.EmbeddedRecordsMixin, {
      attrs: {
        comments: { serialize: 'ids', deserialize: 'records' }
      }
    })
    ```

    ```js
    {
      "post": {
        "id": "1"
        "title": "Rails is omakase",
        "body": "I want this for my ORM, I want that for my template language..."
        "comments": ["1", "2"]
      }
    }
    ```

    To embed the relationship as a collection of objects with `id` and `type` keys, set
    `ids-and-types` for the related object.

    This is particularly useful for polymorphic relationships where records don't share
    the same table and the `id` is not enough information.

    By example having a user that has many pets:

    ```js
    User = DS.Model.extend({
      name:    DS.attr('string'),
      pets: DS.hasMany('pet', { polymorphic: true })
    });

    Pet = DS.Model.extend({
      name: DS.attr('string'),
    });

    Cat = Pet.extend({
      // ...
    });

    Parrot = Pet.extend({
      // ...
    });
    ```

    ```app/serializers/user.js
    import DS from 'ember-data;

    export default DS.RESTSerializer.extend(DS.EmbeddedRecordsMixin, {
      attrs: {
        pets: { serialize: 'ids-and-types', deserialize: 'records' }
      }
    });
    ```

    ```js
    {
      "user": {
        "id": "1"
        "name": "Bertin Osborne",
        "pets": [
          { "id": "1", "type": "Cat" },
          { "id": "1", "type": "Parrot"}
        ]
      }
    }
    ```
  itemtype: method
  name: serializeHasMany
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: json
    description: ''
    type: Object
  - name: relationship
    description: ''
    type: Object
  class: DS.EmbeddedRecordsMixin
  module: ember-data
  namespace: DS
- file: addon/serializers/embedded-records-mixin.js
  line: 455
  description: |-
    When serializing an embedded record, modify the property (in the json payload)
    that refers to the parent record (foreign key for relationship).

    Serializing a `belongsTo` relationship removes the property that refers to the
    parent record

    Serializing a `hasMany` relationship does not remove the property that refers to
    the parent record.
  itemtype: method
  name: removeEmbeddedForeignKey
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: embeddedSnapshot
    description: ''
    type: DS.Snapshot
  - name: relationship
    description: ''
    type: Object
  - name: json
    description: ''
    type: Object
  class: DS.EmbeddedRecordsMixin
  module: ember-data
  namespace: DS
- file: addon/serializers/embedded-records-mixin.js
  line: 532
  itemtype: method
  name: _extractEmbeddedRecords
  access: private
  tagname: ''
  class: DS.EmbeddedRecordsMixin
  module: ember-data
  namespace: DS
- file: addon/serializers/embedded-records-mixin.js
  line: 550
  itemtype: method
  name: _extractEmbeddedHasMany
  access: private
  tagname: ''
  class: DS.EmbeddedRecordsMixin
  module: ember-data
  namespace: DS
- file: addon/serializers/embedded-records-mixin.js
  line: 579
  itemtype: method
  name: _extractEmbeddedBelongsTo
  access: private
  tagname: ''
  class: DS.EmbeddedRecordsMixin
  module: ember-data
  namespace: DS
- file: addon/serializers/embedded-records-mixin.js
  line: 602
  itemtype: method
  name: _normalizeEmbeddedRelationship
  access: private
  tagname: ''
  class: DS.EmbeddedRecordsMixin
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 132
  itemtype: method
  name: _normalizeDocumentHelper
  params:
  - name: documentHash
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  access: private
  tagname: ''
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 167
  itemtype: method
  name: _normalizeRelationshipDataHelper
  params:
  - name: relationshipDataHash
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  access: private
  tagname: ''
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 195
  itemtype: method
  name: _normalizeResourceHelper
  params:
  - name: resourceHash
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  access: private
  tagname: ''
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 241
  itemtype: method
  name: pushPayload
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: payload
    description: ''
    type: Object
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 255
  itemtype: method
  name: _normalizeResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  - name: isSingle
    description: ''
    type: Boolean
  return:
    description: JSON-API Document
    type: Object
  access: private
  tagname: ''
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 344
  itemtype: method
  name: _extractType
  params:
  - name: modelClass
    description: ''
    type: DS.Model
  - name: resourceHash
    description: ''
    type: Object
  return:
    description: ''
    type: String
  access: private
  tagname: ''
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 371
  description: |-
    Dasherizes and singularizes the model name in the payload to match
    the format Ember Data uses internally for the model name.

    For example the key `posts` would be converted to `post` and the
    key `studentAssesments` would be converted to `student-assesment`.
  itemtype: method
  name: modelNameFromPayloadKey
  params:
  - name: key
    description: ''
    type: String
  return:
    description: the model's modelName
    type: String
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 387
  description: |-
    Converts the model name to a pluralized version of the model name.

    For example `post` would be converted to `posts` and
    `student-assesment` would be converted to `student-assesments`.
  itemtype: method
  name: payloadKeyFromModelName
  params:
  - name: modelName
    description: ''
    type: String
  return:
    description: ''
    type: String
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 423
  description: |-
    `keyForAttribute` can be used to define rules for how to convert an
    attribute name in your model to a key in your JSON.
    By default `JSONAPISerializer` follows the format used on the examples of
    http://jsonapi.org/format and uses dashes as the word separator in the JSON
    attribute keys.

    This behaviour can be easily customized by extending this method.

    Example

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.JSONAPISerializer.extend({
      keyForAttribute(attr, method) {
        return Ember.String.dasherize(attr).toUpperCase();
      }
    });
    ```
  itemtype: method
  name: keyForAttribute
  params:
  - name: key
    description: ''
    type: String
  - name: method
    description: ''
    type: String
  return:
    description: normalized key
    type: String
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 453
  description: |-
    `keyForRelationship` can be used to define a custom key when
    serializing and deserializing relationship properties.
    By default `JSONAPISerializer` follows the format used on the examples of
    http://jsonapi.org/format and uses dashes as word separators in
    relationship properties.

    This behaviour can be easily customized by extending this method.

    Example

     ```app/serializers/post.js
     import DS from 'ember-data';

     export default DS.JSONAPISerializer.extend({
       keyForRelationship(key, relationship, method) {
         return Ember.String.underscore(key);
       }
     });
     ```
  itemtype: method
  name: keyForRelationship
  params:
  - name: key
    description: ''
    type: String
  - name: typeClass
    description: ''
    type: String
  - name: method
    description: ''
    type: String
  return:
    description: normalized key
    type: String
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 631
  description: |-
    `modelNameFromPayloadType` can be used to change the mapping for a DS model
    name, taken from the value in the payload.

    Say your API namespaces the type of a model and returns the following
    payload for the `post` model:

    ```javascript
    // GET /api/posts/1
    {
      "data": {
        "id": 1,
        "type: "api::v1::post"
      }
    }
    ```

    By overwriting `modelNameFromPayloadType` you can specify that the
    `post` model should be used:

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.JSONAPISerializer.extend({
      modelNameFromPayloadType(payloadType) {
        return payloadType.replace('api::v1::', '');
      }
    });
    ```

    By default the modelName for a model is its singularized name in dasherized
    form.  Usually, Ember Data can use the correct inflection to do this for
    you. Most of the time, you won't need to override
    `modelNameFromPayloadType` for this purpose.

    Also take a look at
    [payloadTypeFromModelName](#method_payloadTypeFromModelName) to customize
    how the type of a record should be serialized.
  itemtype: method
  name: modelNameFromPayloadType
  access: public
  tagname: ''
  params:
  - name: payloadType
    description: type from payload
    type: String
  return:
    description: modelName
    type: String
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json-api.js
  line: 679
  description: |-
    `payloadTypeFromModelName` can be used to change the mapping for the type in
    the payload, taken from the model name.

    Say your API namespaces the type of a model and expects the following
    payload when you update the `post` model:

    ```javascript
    // POST /api/posts/1
    {
      "data": {
        "id": 1,
        "type": "api::v1::post"
      }
    }
    ```

    By overwriting `payloadTypeFromModelName` you can specify that the
    namespaces model name for the `post` should be used:

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default JSONAPISerializer.extend({
      payloadTypeFromModelName(modelName) {
        return 'api::v1::' + modelName;
      }
    });
    ```

    By default the payload type is the pluralized model name. Usually, Ember
    Data can use the correct inflection to do this for you. Most of the time,
    you won't need to override `payloadTypeFromModelName` for this purpose.

    Also take a look at
    [modelNameFromPayloadType](#method_modelNameFromPayloadType) to customize
    how the model name from should be mapped from the payload.
  itemtype: method
  name: payloadTypeFromModelName
  access: public
  tagname: ''
  params:
  - name: modelname
    description: modelName from the record
    type: String
  return:
    description: payloadType
    type: String
  class: DS.JSONAPISerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 87
  description: |-
    The `primaryKey` is used when serializing and deserializing
    data. Ember Data always uses the `id` property to store the id of
    the record. The external source may not always follow this
    convention. In these cases it is useful to override the
    `primaryKey` property to match the `primaryKey` of your external
    store.

    Example

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      primaryKey: '_id'
    });
    ```
  itemtype: property
  name: primaryKey
  type: "{String}"
  default: "'id'"
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 111
  description: |-
    The `attrs` object can be used to declare a simple mapping between
    property names on `DS.Model` records and payload keys in the
    serialized JSON object representing the record. An object with the
    property `key` can also be used to designate the attribute's key on
    the response payload.

    Example

    ```app/models/person.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      firstName: DS.attr('string'),
      lastName: DS.attr('string'),
      occupation: DS.attr('string'),
      admin: DS.attr('boolean')
    });
    ```

    ```app/serializers/person.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      attrs: {
        admin: 'is_admin',
        occupation: { key: 'career' }
      }
    });
    ```

    You can also remove attributes by setting the `serialize` key to
    `false` in your mapping object.

    Example

    ```app/serializers/person.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      attrs: {
        admin: { serialize: false },
        occupation: { key: 'career' }
      }
    });
    ```

    When serialized:

    ```javascript
    {
      "firstName": "Harry",
      "lastName": "Houdini",
      "career": "magician"
    }
    ```

    Note that the `admin` is now not included in the payload.
  itemtype: property
  name: attrs
  type: "{Object}"
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 175
  description: |-
    Given a subclass of `DS.Model` and a JSON object this method will
    iterate through each attribute of the `DS.Model` and invoke the
    `DS.Transform#deserialize` method on the matching property of the
    JSON object.  This method is typically called after the
    serializer's `normalize` method.
  itemtype: method
  name: applyTransforms
  access: private
  tagname: ''
  params:
  - name: typeClass
    description: ''
    type: DS.Model
  - name: data
    description: The data to transform
    type: Object
  return:
    description: data The transformed data object
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 202
  description: |-
    The `normalizeResponse` method is used to normalize a payload from the
    server to a JSON-API Document.

    http://jsonapi.org/format/#document-structure

    This method delegates to a more specific normalize method based on
    the `requestType`.

    To override this method with a custom one, make sure to call
    `return this._super(store, primaryModelClass, payload, id, requestType)` with your
    pre-processed data.

    Here's an example of using `normalizeResponse` manually:

    ```javascript
    socket.on('message', function(message) {
      var data = message.data;
      var modelClass = store.modelFor(data.modelName);
      var serializer = store.serializerFor(data.modelName);
      var normalized = serializer.normalizeSingleResponse(store, modelClass, data, data.id);

      store.push(normalized);
    });
    ```
  since: 1.13.0
  itemtype: method
  name: normalizeResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 262
  since: 1.13.0
  itemtype: method
  name: normalizeFindRecordResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 276
  since: 1.13.0
  itemtype: method
  name: normalizeQueryRecordResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 290
  since: 1.13.0
  itemtype: method
  name: normalizeFindAllResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 304
  since: 1.13.0
  itemtype: method
  name: normalizeFindBelongsToResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 318
  since: 1.13.0
  itemtype: method
  name: normalizeFindHasManyResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 332
  since: 1.13.0
  itemtype: method
  name: normalizeFindManyResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 346
  since: 1.13.0
  itemtype: method
  name: normalizeQueryResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 360
  since: 1.13.0
  itemtype: method
  name: normalizeCreateRecordResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 374
  since: 1.13.0
  itemtype: method
  name: normalizeDeleteRecordResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 388
  since: 1.13.0
  itemtype: method
  name: normalizeUpdateRecordResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 402
  since: 1.13.0
  itemtype: method
  name: normalizeSaveResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 416
  since: 1.13.0
  itemtype: method
  name: normalizeSingleResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 430
  since: 1.13.0
  itemtype: method
  name: normalizeArrayResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 444
  itemtype: method
  name: _normalizeResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  - name: isSingle
    description: ''
    type: Boolean
  return:
    description: JSON-API Document
    type: Object
  access: private
  tagname: ''
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 491
  description: |-
    Normalizes a part of the JSON payload returned by
    the server. You should override this method, munge the hash
    and call super if you have generic normalization to do.

    It takes the type of the record that is being normalized
    (as a DS.Model class), the property where the hash was
    originally found, and the hash to normalize.

    You can use this method, for example, to normalize underscored keys to camelized
    or other general-purpose normalizations.

    Example

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      normalize(typeClass, hash) {
        var fields = Ember.get(typeClass, 'fields');

        fields.forEach(function(field) {
          var payloadField = Ember.String.underscore(field);
          if (field === payloadField) { return; }

          hash[field] = hash[payloadField];
          delete hash[payloadField];
        });

        return this._super.apply(this, arguments);
      }
    });
    ```
  itemtype: method
  name: normalize
  params:
  - name: typeClass
    description: ''
    type: DS.Model
  - name: hash
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 552
  description: Returns the resource's ID.
  itemtype: method
  name: extractId
  params:
  - name: modelClass
    description: ''
    type: Object
  - name: resourceHash
    description: ''
    type: Object
  return:
    description: ''
    type: String
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 566
  description: |-
    Returns the resource's attributes formatted as a JSON-API "attributes object".

    http://jsonapi.org/format/#document-resource-object-attributes
  itemtype: method
  name: extractAttributes
  params:
  - name: modelClass
    description: ''
    type: Object
  - name: resourceHash
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 590
  description: |-
    Returns a relationship formatted as a JSON-API "relationship object".

    http://jsonapi.org/format/#document-resource-object-relationships
  itemtype: method
  name: extractRelationship
  params:
  - name: relationshipModelName
    description: ''
    type: Object
  - name: relationshipHash
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 639
  description: |-
    Returns a polymorphic relationship formatted as a JSON-API "relationship object".

    http://jsonapi.org/format/#document-resource-object-relationships

    `relationshipOptions` is a hash which contains more information about the
    polymorphic relationship which should be extracted:
      - `resourceHash` complete hash of the resource the relationship should be
        extracted from
      - `relationshipKey` key under which the value for the relationship is
        extracted from the resourceHash
      - `relationshipMeta` meta information about the relationship
  itemtype: method
  name: extractPolymorphicRelationship
  params:
  - name: relationshipModelName
    description: ''
    type: Object
  - name: relationshipHash
    description: ''
    type: Object
  - name: relationshipOptions
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 662
  description: |-
    Returns the resource's relationships formatted as a JSON-API "relationships object".

    http://jsonapi.org/format/#document-resource-object-relationships
  itemtype: method
  name: extractRelationships
  params:
  - name: modelClass
    description: ''
    type: Object
  - name: resourceHash
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 718
  itemtype: method
  name: modelNameFromPayloadKey
  params:
  - name: key
    description: ''
    type: String
  return:
    description: the model's modelName
    type: String
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 728
  itemtype: method
  name: normalizeRelationships
  access: private
  tagname: ''
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 747
  itemtype: method
  name: normalizeUsingDeclaredMapping
  access: private
  tagname: ''
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 778
  description: |-
    Looks up the property key that was set by the custom `attr` mapping
    passed to the serializer.
  itemtype: method
  name: _getMappedKey
  access: private
  tagname: ''
  params:
  - name: key
    description: ''
    type: String
  return:
    description: key
    type: String
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 809
  description: |-
    Check attrs.key.serialize property to inform if the `key`
    can be serialized
  itemtype: method
  name: _canSerialize
  access: private
  tagname: ''
  params:
  - name: key
    description: ''
    type: String
  return:
    description: true if the key can be serialized
    type: Boolean
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 824
  description: |-
    When attrs.key.serialize is set to true then
    it takes priority over the other checks and the related
    attribute/relationship will be serialized
  itemtype: method
  name: _mustSerialize
  access: private
  tagname: ''
  params:
  - name: key
    description: ''
    type: String
  return:
    description: true if the key must be serialized
    type: Boolean
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 840
  description: Check if the given hasMany relationship should be serialized
  itemtype: method
  name: shouldSerializeHasMany
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: key
    description: ''
    type: String
  - name: relationshipType
    description: ''
    type: String
  return:
    description: true if the hasMany relationship should be serialized
    type: Boolean
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 861
  description: Check if the given hasMany relationship should be serialized
  itemtype: method
  name: _shouldSerializeHasMany
  access: private
  tagname: ''
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: key
    description: ''
    type: String
  - name: relationshipType
    description: ''
    type: String
  return:
    description: true if the hasMany relationship should be serialized
    type: Boolean
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 881
  description: |-
    Called when a record is saved in order to convert the
    record into JSON.

    By default, it creates a JSON object with a key for
    each attribute and belongsTo relationship.

    For example, consider this model:

    ```app/models/comment.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      title: DS.attr(),
      body: DS.attr(),

      author: DS.belongsTo('user')
    });
    ```

    The default serialization would create a JSON object like:

    ```javascript
    {
      "title": "Rails is unagi",
      "body": "Rails? Omakase? O_O",
      "author": 12
    }
    ```

    By default, attributes are passed through as-is, unless
    you specified an attribute type (`DS.attr('date')`). If
    you specify a transform, the JavaScript value will be
    serialized when inserted into the JSON hash.

    By default, belongs-to relationships are converted into
    IDs when inserted into the JSON hash.

    ## IDs

    `serialize` takes an options hash with a single option:
    `includeId`. If this option is `true`, `serialize` will,
    by default include the ID in the JSON object it builds.

    The adapter passes in `includeId: true` when serializing
    a record for `createRecord`, but not for `updateRecord`.

    ## Customization

    Your server may expect a different JSON format than the
    built-in serialization format.

    In that case, you can implement `serialize` yourself and
    return a JSON hash of your choosing.

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      serialize(snapshot, options) {
        var json = {
          POST_TTL: snapshot.attr('title'),
          POST_BDY: snapshot.attr('body'),
          POST_CMS: snapshot.hasMany('comments', { ids: true })
        };

        if (options.includeId) {
          json.POST_ID_ = snapshot.id;
        }

        return json;
      }
    });
    ```

    ## Customizing an App-Wide Serializer

    If you want to define a serializer for your entire
    application, you'll probably want to use `eachAttribute`
    and `eachRelationship` on the record.

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      serialize(snapshot, options) {
        var json = {};

        snapshot.eachAttribute(function(name) {
          json[serverAttributeName(name)] = snapshot.attr(name);
        });

        snapshot.eachRelationship(function(name, relationship) {
          if (relationship.kind === 'hasMany') {
            json[serverHasManyName(name)] = snapshot.hasMany(name, { ids: true });
          }
        });

        if (options.includeId) {
          json.ID_ = snapshot.id;
        }

        return json;
      }
    });

    function serverAttributeName(attribute) {
      return attribute.underscore().toUpperCase();
    }

    function serverHasManyName(name) {
      return serverAttributeName(name.singularize()) + "_IDS";
    }
    ```

    This serializer will generate JSON that looks like this:

    ```javascript
    {
      "TITLE": "Rails is omakase",
      "BODY": "Yep. Omakase.",
      "COMMENT_IDS": [ 1, 2, 3 ]
    }
    ```

    ## Tweaking the Default JSON

    If you just want to do some small tweaks on the default JSON,
    you can call super first and make the tweaks on the returned
    JSON.

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      serialize(snapshot, options) {
        var json = this._super(...arguments);

        json.subject = json.title;
        delete json.title;

        return json;
      }
    });
    ```
  itemtype: method
  name: serialize
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: options
    description: ''
    type: Object
  return:
    description: json
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1061
  description: |-
    You can use this method to customize how a serialized record is added to the complete
    JSON hash to be sent to the server. By default the JSON Serializer does not namespace
    the payload and just sends the raw serialized JSON object.
    If your server expects namespaced keys, you should consider using the RESTSerializer.
    Otherwise you can override this method to customize how the record is added to the hash.
    The hash property should be modified by reference.

    For example, your server may expect underscored root objects.

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      serializeIntoHash(data, type, snapshot, options) {
        var root = Ember.String.decamelize(type.modelName);
        data[root] = this.serialize(snapshot, options);
      }
    });
    ```
  itemtype: method
  name: serializeIntoHash
  params:
  - name: hash
    description: ''
    type: Object
  - name: typeClass
    description: ''
    type: DS.Model
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: options
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1092
  description: |-
    `serializeAttribute` can be used to customize how `DS.attr`
    properties are serialized

    For example if you wanted to ensure all your attributes were always
    serialized as properties on an `attributes` object you could
    write:

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      serializeAttribute(snapshot, json, key, attributes) {
        json.attributes = json.attributes || {};
        this._super(snapshot, json.attributes, key, attributes);
      }
    });
    ```
  itemtype: method
  name: serializeAttribute
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: json
    description: ''
    type: Object
  - name: key
    description: ''
    type: String
  - name: attribute
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1139
  description: |-
    `serializeBelongsTo` can be used to customize how `DS.belongsTo`
    properties are serialized.

    Example

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      serializeBelongsTo(snapshot, json, relationship) {
        var key = relationship.key;
        var belongsTo = snapshot.belongsTo(key);

        key = this.keyForRelationship ? this.keyForRelationship(key, "belongsTo", "serialize") : key;

        json[key] = Ember.isNone(belongsTo) ? belongsTo : belongsTo.record.toJSON();
      }
    });
    ```
  itemtype: method
  name: serializeBelongsTo
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: json
    description: ''
    type: Object
  - name: relationship
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1191
  description: |-
    `serializeHasMany` can be used to customize how `DS.hasMany`
    properties are serialized.

    Example

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      serializeHasMany(snapshot, json, relationship) {
        var key = relationship.key;
        if (key === 'comments') {
          return;
        } else {
          this._super(...arguments);
        }
      }
    });
    ```
  itemtype: method
  name: serializeHasMany
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: json
    description: ''
    type: Object
  - name: relationship
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1240
  description: |-
    You can use this method to customize how polymorphic objects are
    serialized. Objects are considered to be polymorphic if
    `{ polymorphic: true }` is pass as the second argument to the
    `DS.belongsTo` function.

    Example

    ```app/serializers/comment.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      serializePolymorphicType(snapshot, json, relationship) {
        var key = relationship.key;
        var belongsTo = snapshot.belongsTo(key);

        key = this.keyForAttribute ? this.keyForAttribute(key, 'serialize') : key;

        if (Ember.isNone(belongsTo)) {
          json[key + '_type'] = null;
        } else {
          json[key + '_type'] = belongsTo.modelName;
        }
      }
    });
    ```
  itemtype: method
  name: serializePolymorphicType
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: json
    description: ''
    type: Object
  - name: relationship
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1274
  description: |-
    `extractMeta` is used to deserialize any meta information in the
    adapter payload. By default Ember Data expects meta information to
    be located on the `meta` property of the payload object.

    Example

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      extractMeta(store, typeClass, payload) {
        if (payload && payload.hasOwnProperty('_pagination')) {
          let meta = payload._pagination;
          delete payload._pagination;
          return meta;
        }
      }
    });
    ```
  itemtype: method
  name: extractMeta
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: modelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1308
  description: |-
    `extractErrors` is used to extract model errors when a call
    to `DS.Model#save` fails with an `InvalidError`. By default
    Ember Data expects error information to be located on the `errors`
    property of the payload object.

    This serializer expects this `errors` object to be an Array similar
    to the following, compliant with the JSON-API specification:

    ```js
    {
      "errors": [
        {
          "detail": "This username is already taken!",
          "source": {
            "pointer": "data/attributes/username"
          }
        }, {
          "detail": "Doesn't look like a valid email.",
          "source": {
            "pointer": "data/attributes/email"
          }
        }
      ]
    }
    ```

    The key `detail` provides a textual description of the problem.
    Alternatively, the key `title` can be used for the same purpose.

    The nested keys `source.pointer` detail which specific element
    of the request data was invalid.

    Note that JSON-API also allows for object-level errors to be placed
    in an object with pointer `data`, signifying that the problem
    cannot be traced to a specific attribute:

    ```javascript
    {
      "errors": [
        {
          "detail": "Some generic non property error message",
          "source": {
            "pointer": "data"
          }
        }
      ]
    }
    ```

    When turn into a `DS.Errors` object, you can read these errors
    through the property `base`:

    ```handlebars
    {{#each model.errors.base as |error|}}
      <div class="error">
        {{error.message}}
      </div>
    {{/each}}
    ```

    Example of alternative implementation, overriding the default
    behavior to deal with a different format of errors:

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
      extractErrors(store, typeClass, payload, id) {
        if (payload && typeof payload === 'object' && payload._problems) {
          payload = payload._problems;
          this.normalizeErrors(typeClass, payload);
        }
        return payload;
      }
    });
    ```
  itemtype: method
  name: extractErrors
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: typeClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: "(String|Number)"
  return:
    description: json The deserialized errors
    type: Object
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1419
  description: |-
    `keyForAttribute` can be used to define rules for how to convert an
    attribute name in your model to a key in your JSON.

    Example

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      keyForAttribute(attr, method) {
        return Ember.String.underscore(attr).toUpperCase();
      }
    });
    ```
  itemtype: method
  name: keyForAttribute
  params:
  - name: key
    description: ''
    type: String
  - name: method
    description: ''
    type: String
  return:
    description: normalized key
    type: String
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1444
  description: |-
    `keyForRelationship` can be used to define a custom key when
    serializing and deserializing relationship properties. By default
    `JSONSerializer` does not provide an implementation of this method.

    Example

     ```app/serializers/post.js
     import DS from 'ember-data';

     export default DS.JSONSerializer.extend({
       keyForRelationship(key, relationship, method) {
         return 'rel_' + Ember.String.underscore(key);
       }
     });
     ```
  itemtype: method
  name: keyForRelationship
  params:
  - name: key
    description: ''
    type: String
  - name: typeClass
    description: ''
    type: String
  - name: method
    description: ''
    type: String
  return:
    description: normalized key
    type: String
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1471
  description: |-
    `keyForLink` can be used to define a custom key when deserializing link
    properties.
  itemtype: method
  name: keyForLink
  params:
  - name: key
    description: ''
    type: String
  - name: kind
    description: "`belongsTo` or `hasMany`"
    type: String
  return:
    description: normalized key
    type: String
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1486
  itemtype: method
  name: transformFor
  access: private
  tagname: ''
  params:
  - name: attributeType
    description: ''
    type: String
  - name: skipAssertion
    description: ''
    type: Boolean
  return:
    description: transform
    type: DS.Transform
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1506
  itemtype: method
  name: modelNameFromPayloadType
  access: public
  tagname: ''
  params:
  - name: type
    description: ''
    type: String
  return:
    description: the model's modelName
    type: String
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/json.js
  line: 1528
  description: |-
    serializeId can be used to customize how id is serialized
    For example, your server may expect integer datatype of id

    By default the snapshot's id (String) is set on the json hash via json[primaryKey] = snapshot.id.

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.JSONSerializer.extend({
    serializeId(snapshot, json, primaryKey) {
        var id = snapshot.id;
        json[primaryKey] = parseInt(id, 10);
      }
    });
    ```
  itemtype: method
  name: serializeId
  access: public
  tagname: ''
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: json
    description: ''
    type: Object
  - name: primaryKey
    description: ''
    type: String
  class: DS.JSONSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 60
  description: |-
    `keyForPolymorphicType` can be used to define a custom key when
    serializing and deserializing a polymorphic type. By default, the
    returned key is `${key}Type`.

    Example

     ```app/serializers/post.js
     import DS from 'ember-data';

     export default DS.RESTSerializer.extend({
       keyForPolymorphicType(key, relationship) {
         var relationshipKey = this.keyForRelationship(key);

         return 'type-' + relationshipKey;
       }
     });
     ```
  itemtype: method
  name: keyForPolymorphicType
  params:
  - name: key
    description: ''
    type: String
  - name: typeClass
    description: ''
    type: String
  - name: method
    description: ''
    type: String
  return:
    description: normalized key
    type: String
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 91
  description: |-
    Normalizes a part of the JSON payload returned by
    the server. You should override this method, munge the hash
    and call super if you have generic normalization to do.

    It takes the type of the record that is being normalized
    (as a DS.Model class), the property where the hash was
    originally found, and the hash to normalize.

    For example, if you have a payload that looks like this:

    ```js
    {
      "post": {
        "id": 1,
        "title": "Rails is omakase",
        "comments": [ 1, 2 ]
      },
      "comments": [{
        "id": 1,
        "body": "FIRST"
      }, {
        "id": 2,
        "body": "Rails is unagi"
      }]
    }
    ```

    The `normalize` method will be called three times:

    * With `App.Post`, `"posts"` and `{ id: 1, title: "Rails is omakase", ... }`
    * With `App.Comment`, `"comments"` and `{ id: 1, body: "FIRST" }`
    * With `App.Comment`, `"comments"` and `{ id: 2, body: "Rails is unagi" }`

    You can use this method, for example, to normalize underscored keys to camelized
    or other general-purpose normalizations. You will only need to implement
    `normalize` and manipulate the payload as desired.

    For example, if the `IDs` under `"comments"` are provided as `_id` instead of
    `id`, you can specify how to normalize just the comments:

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      normalize(model, hash, prop) {
        if (prop === 'comments') {
          hash.id = hash._id;
          delete hash._id;
        }

        return this._super(...arguments);
      }
    });
    ```

    On each call to the `normalize` method, the third parameter (`prop`) is always
    one of the keys that were in the original payload or in the result of another
    normalization as `normalizeResponse`.
  itemtype: method
  name: normalize
  params:
  - name: modelClass
    description: ''
    type: DS.Model
  - name: resourceHash
    description: ''
    type: Object
  - name: prop
    description: ''
    type: String
  return:
    description: ''
    type: Object
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 168
  description: |-
    Normalizes an array of resource payloads and returns a JSON-API Document
    with primary data and, if any, included data as `{ data, included }`.
  itemtype: method
  name: _normalizeArray
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: modelName
    description: ''
    type: String
  - name: arrayHash
    description: ''
    type: Object
  - name: prop
    description: ''
    type: String
  return:
    description: ''
    type: Object
  access: private
  tagname: ''
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 379
  description: |-
    This method allows you to push a payload containing top-level
    collections of records organized per type.

    ```js
    {
      "posts": [{
        "id": "1",
        "title": "Rails is omakase",
        "author", "1",
        "comments": [ "1" ]
      }],
      "comments": [{
        "id": "1",
        "body": "FIRST"
      }],
      "users": [{
        "id": "1",
        "name": "@d2h"
      }]
    }
    ```

    It will first normalize the payload, so you can use this to push
    in data streaming in from your server structured the same way
    that fetches and saves are structured.
  itemtype: method
  name: pushPayload
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: payload
    description: ''
    type: Object
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 443
  description: |-
    This method is used to convert each JSON root key in the payload
    into a modelName that it can use to look up the appropriate model for
    that part of the payload.

    For example, your server may send a model name that does not correspond with
    the name of the model in your app. Let's take a look at an example model,
    and an example payload:

    ```app/models/post.js
    import DS from 'ember-data';

    export default DS.Model.extend({
    });
    ```

    ```javascript
      {
        "blog/post": {
          "id": "1
        }
      }
    ```

    Ember Data is going to normalize the payload's root key for the modelName. As a result,
    it will try to look up the "blog/post" model. Since we don't have a model called "blog/post"
    (or a file called app/models/blog/post.js in ember-cli), Ember Data will throw an error
    because it cannot find the "blog/post" model.

    Since we want to remove this namespace, we can define a serializer for the application that will
    remove "blog/" from the payload key whenver it's encountered by Ember Data:

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      modelNameFromPayloadKey(payloadKey) {
        if (payloadKey === 'blog/post') {
          return this._super(payloadKey.replace('blog/', ''));
        } else {
         return this._super(payloadKey);
        }
      }
    });
    ```

    After refreshing, Ember Data will appropriately look up the "post" model.

    By default the modelName for a model is its
    name in dasherized form. This means that a payload key like "blogPost" would be
    normalized to "blog-post" when Ember Data looks up the model. Usually, Ember Data
    can use the correct inflection to do this for you. Most of the time, you won't
    need to override `modelNameFromPayloadKey` for this purpose.
  itemtype: method
  name: modelNameFromPayloadKey
  params:
  - name: key
    description: ''
    type: String
  return:
    description: the model's modelName
    type: String
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 507
  description: |-
    Called when a record is saved in order to convert the
    record into JSON.

    By default, it creates a JSON object with a key for
    each attribute and belongsTo relationship.

    For example, consider this model:

    ```app/models/comment.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      title: DS.attr(),
      body: DS.attr(),

      author: DS.belongsTo('user')
    });
    ```

    The default serialization would create a JSON object like:

    ```js
    {
      "title": "Rails is unagi",
      "body": "Rails? Omakase? O_O",
      "author": 12
    }
    ```

    By default, attributes are passed through as-is, unless
    you specified an attribute type (`DS.attr('date')`). If
    you specify a transform, the JavaScript value will be
    serialized when inserted into the JSON hash.

    By default, belongs-to relationships are converted into
    IDs when inserted into the JSON hash.

    ## IDs

    `serialize` takes an options hash with a single option:
    `includeId`. If this option is `true`, `serialize` will,
    by default include the ID in the JSON object it builds.

    The adapter passes in `includeId: true` when serializing
    a record for `createRecord`, but not for `updateRecord`.

    ## Customization

    Your server may expect a different JSON format than the
    built-in serialization format.

    In that case, you can implement `serialize` yourself and
    return a JSON hash of your choosing.

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      serialize(snapshot, options) {
        var json = {
          POST_TTL: snapshot.attr('title'),
          POST_BDY: snapshot.attr('body'),
          POST_CMS: snapshot.hasMany('comments', { ids: true })
        };

        if (options.includeId) {
          json.POST_ID_ = snapshot.id;
        }

        return json;
      }
    });
    ```

    ## Customizing an App-Wide Serializer

    If you want to define a serializer for your entire
    application, you'll probably want to use `eachAttribute`
    and `eachRelationship` on the record.

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      serialize(snapshot, options) {
        var json = {};

        snapshot.eachAttribute(function(name) {
          json[serverAttributeName(name)] = snapshot.attr(name);
        });

        snapshot.eachRelationship(function(name, relationship) {
          if (relationship.kind === 'hasMany') {
            json[serverHasManyName(name)] = snapshot.hasMany(name, { ids: true });
          }
        });

        if (options.includeId) {
          json.ID_ = snapshot.id;
        }

        return json;
      }
    });

    function serverAttributeName(attribute) {
      return attribute.underscore().toUpperCase();
    }

    function serverHasManyName(name) {
      return serverAttributeName(name.singularize()) + "_IDS";
    }
    ```

    This serializer will generate JSON that looks like this:

    ```js
    {
      "TITLE": "Rails is omakase",
      "BODY": "Yep. Omakase.",
      "COMMENT_IDS": [ 1, 2, 3 ]
    }
    ```

    ## Tweaking the Default JSON

    If you just want to do some small tweaks on the default JSON,
    you can call super first and make the tweaks on the returned
    JSON.

    ```app/serializers/post.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      serialize(snapshot, options) {
        var json = this._super(snapshot, options);

        json.subject = json.title;
        delete json.title;

        return json;
      }
    });
    ```
  itemtype: method
  name: serialize
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: options
    description: ''
    type: Object
  return:
    description: json
    type: Object
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 662
  description: |-
    You can use this method to customize the root keys serialized into the JSON.
    The hash property should be modified by reference (possibly using something like _.extend)
    By default the REST Serializer sends the modelName of a model, which is a camelized
    version of the name.

    For example, your server may expect underscored root objects.

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      serializeIntoHash(data, type, record, options) {
        var root = Ember.String.decamelize(type.modelName);
        data[root] = this.serialize(record, options);
      }
    });
    ```
  itemtype: method
  name: serializeIntoHash
  params:
  - name: hash
    description: ''
    type: Object
  - name: typeClass
    description: ''
    type: DS.Model
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: options
    description: ''
    type: Object
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 692
  description: |-
    You can use `payloadKeyFromModelName` to override the root key for an outgoing
    request. By default, the RESTSerializer returns a camelized version of the
    model's name.

    For a model called TacoParty, its `modelName` would be the string `taco-party`. The RESTSerializer
    will send it to the server with `tacoParty` as the root key in the JSON payload:

    ```js
    {
      "tacoParty": {
        "id": "1",
        "location": "Matthew Beale's House"
      }
    }
    ```

    For example, your server may expect dasherized root objects:

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      payloadKeyFromModelName(modelName) {
        return Ember.String.dasherize(modelName);
      }
    });
    ```

    Given a `TacoParty` model, calling `save` on it would produce an outgoing
    request like:

    ```js
    {
      "taco-party": {
        "id": "1",
        "location": "Matthew Beale's House"
      }
    }
    ```
  itemtype: method
  name: payloadKeyFromModelName
  params:
  - name: modelName
    description: ''
    type: String
  return:
    description: ''
    type: String
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 741
  description: |-
    You can use this method to customize how polymorphic objects are serialized.
    By default the REST Serializer creates the key by appending `Type` to
    the attribute and value from the model's camelcased model name.
  itemtype: method
  name: serializePolymorphicType
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: json
    description: ''
    type: Object
  - name: relationship
    description: ''
    type: Object
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 785
  description: |-
    You can use this method to customize how a polymorphic relationship should
    be extracted.
  itemtype: method
  name: extractPolymorphicRelationship
  params:
  - name: relationshipType
    description: ''
    type: Object
  - name: relationshipHash
    description: ''
    type: Object
  - name: relationshipOptions
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 860
  description: |-
    `modelNameFromPayloadType` can be used to change the mapping for a DS model
    name, taken from the value in the payload.

    Say your API namespaces the type of a model and returns the following
    payload for the `post` model, which has a polymorphic `user` relationship:

    ```javascript
    // GET /api/posts/1
    {
      "post": {
        "id": 1,
        "user": 1,
        "userType: "api::v1::administrator"
      }
    }
    ```

    By overwriting `modelNameFromPayloadType` you can specify that the
    `administrator` model should be used:

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      modelNameFromPayloadType(payloadType) {
        return payloadType.replace('api::v1::', '');
      }
    });
    ```

    By default the modelName for a model is its name in dasherized form.
    Usually, Ember Data can use the correct inflection to do this for you. Most
    of the time, you won't need to override `modelNameFromPayloadType` for this
    purpose.

    Also take a look at
    [payloadTypeFromModelName](#method_payloadTypeFromModelName) to customize
    how the type of a record should be serialized.
  itemtype: method
  name: modelNameFromPayloadType
  access: public
  tagname: ''
  params:
  - name: payloadType
    description: type from payload
    type: String
  return:
    description: modelName
    type: String
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/serializers/rest.js
  line: 909
  description: |-
    `payloadTypeFromModelName` can be used to change the mapping for the type in
    the payload, taken from the model name.

    Say your API namespaces the type of a model and expects the following
    payload when you update the `post` model, which has a polymorphic `user`
    relationship:

    ```javascript
    // POST /api/posts/1
    {
      "post": {
        "id": 1,
        "user": 1,
        "userType": "api::v1::administrator"
      }
    }
    ```

    By overwriting `payloadTypeFromModelName` you can specify that the
    namespaces model name for the `administrator` should be used:

    ```app/serializers/application.js
    import DS from 'ember-data';

    export default DS.RESTSerializer.extend({
      payloadTypeFromModelName(modelName) {
        return 'api::v1::' + modelName;
      }
    });
    ```

    By default the payload type is the camelized model name. Usually, Ember
    Data can use the correct inflection to do this for you. Most of the time,
    you won't need to override `payloadTypeFromModelName` for this purpose.

    Also take a look at
    [modelNameFromPayloadType](#method_modelNameFromPayloadType) to customize
    how the model name from should be mapped from the payload.
  itemtype: method
  name: payloadTypeFromModelName
  access: public
  tagname: ''
  params:
  - name: modelName
    description: modelName from the record
    type: String
  return:
    description: payloadType
    type: String
  class: DS.RESTSerializer
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 65
  description: |-
    If you would like your adapter to use a custom serializer you can
    set the `defaultSerializer` property to be the name of the custom
    serializer.

    Note the `defaultSerializer` serializer has a lower priority than
    a model specific serializer (i.e. `PostSerializer`) or the
    `application` serializer.

    ```app/adapters/django.js
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      defaultSerializer: 'django'
    });
    ```
  itemtype: property
  name: defaultSerializer
  type: "{String}"
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 87
  description: |-
    The `findRecord()` method is invoked when the store is asked for a record that
    has not previously been loaded. In response to `findRecord()` being called, you
    should query your persistence layer for a record with the given ID. The `findRecord`
    method should return a promise that will resolve to a JavaScript object that will be
    normalized by the serializer.

    Here is an example `findRecord` implementation:

    ```app/adapters/application.js
    import Ember from 'ember';
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      findRecord(store, type, id, snapshot) {
        return new Ember.RSVP.Promise(function(resolve, reject) {
          Ember.$.getJSON(`/${type.modelName}/${id}`).then(function(data) {
            resolve(data);
          }, function(jqXHR) {
            reject(jqXHR);
          });
        });
      }
    });
    ```
  itemtype: method
  name: findRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: id
    description: ''
    type: String
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: promise
    type: Promise
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 122
  description: |-
    The `findAll()` method is used to retrieve all records for a given type.

    Example

    ```app/adapters/application.js
    import Ember from 'ember';
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      findAll(store, type, sinceToken) {
        let query = { since: sinceToken };

        return new Ember.RSVP.Promise(function(resolve, reject) {
          Ember.$.getJSON(`/${type.modelName}`, query).then(function(data) {
            resolve(data);
          }, function(jqXHR) {
            reject(jqXHR);
          });
        });
      }
    });
    ```
  itemtype: method
  name: findAll
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: sinceToken
    description: ''
    type: String
  - name: snapshotRecordArray
    description: ''
    type: DS.SnapshotRecordArray
  return:
    description: promise
    type: Promise
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 155
  description: |-
    This method is called when you call `query` on the store.

    Example

    ```app/adapters/application.js
    import Ember from 'ember';
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      query(store, type, query) {
        return new Ember.RSVP.Promise(function(resolve, reject) {
          Ember.$.getJSON(`/${type.modelName}`, query).then(function(data) {
            resolve(data);
          }, function(jqXHR) {
            reject(jqXHR);
          });
        });
      }
    });
    ```
  itemtype: method
  name: query
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: DS.Model
  - name: query
    description: ''
    type: Object
  - name: recordArray
    description: ''
    type: DS.AdapterPopulatedRecordArray
  return:
    description: promise
    type: Promise
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 186
  description: |-
    The `queryRecord()` method is invoked when the store is asked for a single
    record through a query object.

    In response to `queryRecord()` being called, you should always fetch fresh
    data. Once found, you can asynchronously call the store's `push()` method
    to push the record into the store.

    Here is an example `queryRecord` implementation:

    Example

    ```app/adapters/application.js
    import Ember from 'ember';
    import DS from 'ember-data';

    export default DS.Adapter.extend(DS.BuildURLMixin, {
      queryRecord(store, type, query) {
        return new Ember.RSVP.Promise(function(resolve, reject) {
          Ember.$.getJSON(`/${type.modelName}`, query).then(function(data) {
            resolve(data);
          }, function(jqXHR) {
            reject(jqXHR);
          });
        });
      }
    });
    ```
  itemtype: method
  name: queryRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: ''
    type: subclass of DS.Model
  - name: query
    description: ''
    type: Object
  return:
    description: promise
    type: Promise
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 223
  description: |-
    If the globally unique IDs for your records should be generated on the client,
    implement the `generateIdForRecord()` method. This method will be invoked
    each time you create a new record, and the value returned from it will be
    assigned to the record's `primaryKey`.

    Most traditional REST-like HTTP APIs will not use this method. Instead, the ID
    of the record will be set by the server, and your adapter will update the store
    with the new ID when it calls `didCreateRecord()`. Only implement this method if
    you intend to generate record IDs on the client-side.

    The `generateIdForRecord()` method will be invoked with the requesting store as
    the first parameter and the newly created record as the second parameter:

    ```javascript
    import DS from 'ember-data';
    import { v4 } from 'uuid';

    export default DS.Adapter.extend({
      generateIdForRecord(store, inputProperties) {
        return v4();
      }
    });
    ```
  itemtype: method
  name: generateIdForRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: the DS.Model class of the record
    type: DS.Model
  - name: inputProperties
    description: |-
      a hash of properties to set on the
        newly created record.
    type: Object
  return:
    description: id
    type: "(String|Number)"
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 257
  description: |-
    Proxies to the serializer's `serialize` method.

    Example

    ```app/adapters/application.js
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      createRecord(store, type, snapshot) {
        let data = this.serialize(snapshot, { includeId: true });
        let url = `/${type.modelName}`;

        // ...
      }
    });
    ```
  itemtype: method
  name: serialize
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: options
    description: ''
    type: Object
  return:
    description: serialized snapshot
    type: Object
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 284
  description: |-
    Implement this method in a subclass to handle the creation of
    new records.

    Serializes the record and sends it to the server.

    Example

    ```app/adapters/application.js
    import Ember from 'ember';
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      createRecord(store, type, snapshot) {
        let data = this.serialize(snapshot, { includeId: true });

        return new Ember.RSVP.Promise(function(resolve, reject) {
          Ember.$.ajax({
            type: 'POST',
            url: `/${type.modelName}`,
            dataType: 'json',
            data: data
          }).then(function(data) {
            Ember.run(null, resolve, data);
          }, function(jqXHR) {
            jqXHR.then = null; // tame jQuery's ill mannered promises
            Ember.run(null, reject, jqXHR);
          });
        });
      }
    });
    ```
  itemtype: method
  name: createRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: the DS.Model class of the record
    type: DS.Model
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: promise
    type: Promise
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 325
  description: |-
    Implement this method in a subclass to handle the updating of
    a record.

    Serializes the record update and sends it to the server.

    The updateRecord method is expected to return a promise that will
    resolve with the serialized record. This allows the backend to
    inform the Ember Data store the current state of this record after
    the update. If it is not possible to return a serialized record
    the updateRecord promise can also resolve with `undefined` and the
    Ember Data store will assume all of the updates were successfully
    applied on the backend.

    Example

    ```app/adapters/application.js
    import Ember from 'ember';
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      updateRecord(store, type, snapshot) {
        let data = this.serialize(snapshot, { includeId: true });
        let id = snapshot.id;

        return new Ember.RSVP.Promise(function(resolve, reject) {
          Ember.$.ajax({
            type: 'PUT',
            url: `/${type.modelName}/${id}`,
            dataType: 'json',
            data: data
          }).then(function(data) {
            Ember.run(null, resolve, data);
          }, function(jqXHR) {
            jqXHR.then = null; // tame jQuery's ill mannered promises
            Ember.run(null, reject, jqXHR);
          });
        });
      }
    });
    ```
  itemtype: method
  name: updateRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: the DS.Model class of the record
    type: DS.Model
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: promise
    type: Promise
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 375
  description: |-
    Implement this method in a subclass to handle the deletion of
    a record.

    Sends a delete request for the record to the server.

    Example

    ```app/adapters/application.js
    import Ember from 'ember';
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      deleteRecord(store, type, snapshot) {
        let data = this.serialize(snapshot, { includeId: true });
        let id = snapshot.id;

        return new Ember.RSVP.Promise(function(resolve, reject) {
          Ember.$.ajax({
            type: 'DELETE',
            url: `/${type.modelName}/${id}`,
            dataType: 'json',
            data: data
          }).then(function(data) {
            Ember.run(null, resolve, data);
          }, function(jqXHR) {
            jqXHR.then = null; // tame jQuery's ill mannered promises
            Ember.run(null, reject, jqXHR);
          });
        });
      }
    });
    ```
  itemtype: method
  name: deleteRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: the DS.Model class of the record
    type: DS.Model
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: promise
    type: Promise
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 417
  description: |-
    By default the store will try to coalesce all `fetchRecord` calls within the same runloop
    into as few requests as possible by calling groupRecordsForFindMany and passing it into a findMany call.
    You can opt out of this behaviour by either not implementing the findMany hook or by setting
    coalesceFindRequests to false.
  itemtype: property
  name: coalesceFindRequests
  type: "{boolean}"
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 428
  description: |-
    The store will call `findMany` instead of multiple `findRecord`
    requests to find multiple records at once if coalesceFindRequests
    is true.

    ```app/adapters/application.js
    import Ember from 'ember';
    import DS from 'ember-data';

    export default DS.Adapter.extend({
      findMany(store, type, ids, snapshots) {
        return new Ember.RSVP.Promise(function(resolve, reject) {
          Ember.$.ajax({
            type: 'GET',
            url: `/${type.modelName}/`,
            dataType: 'json',
            data: { filter: { id: ids.join(',') } }
          }).then(function(data) {
            Ember.run(null, resolve, data);
          }, function(jqXHR) {
            jqXHR.then = null; // tame jQuery's ill mannered promises
            Ember.run(null, reject, jqXHR);
          });
        });
      }
    });
    ```
  itemtype: method
  name: findMany
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: type
    description: the DS.Model class of the records
    type: DS.Model
  - name: ids
    description: ''
    type: Array
  - name: snapshots
    description: ''
    type: Array
  return:
    description: promise
    type: Promise
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 465
  description: |-
    Organize records into groups, each of which is to be passed to separate
    calls to `findMany`.

    For example, if your api has nested URLs that depend on the parent, you will
    want to group records by their parent.

    The default implementation returns the records as a single group.
  itemtype: method
  name: groupRecordsForFindMany
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: snapshots
    description: ''
    type: Array
  return:
    description: |-
      an array of arrays of records, each of which is to be
                        loaded separately by `findMany`.
    type: Array
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 485
  description: |-
    This method is used by the store to determine if the store should
    reload a record from the adapter when a record is requested by
    `store.findRecord`.

    If this method returns `true`, the store will re-fetch a record from
    the adapter. If this method returns `false`, the store will resolve
    immediately using the cached record.

    For example, if you are building an events ticketing system, in which users
    can only reserve tickets for 20 minutes at a time, and want to ensure that
    in each route you have data that is no more than 20 minutes old you could
    write:

    ```javascript
    shouldReloadRecord(store, ticketSnapshot) {
      let lastAccessedAt = ticketSnapshot.attr('lastAccessedAt');
      let timeDiff = moment().diff(lastAccessedAt, 'minutes');

      if (timeDiff > 20) {
        return true;
      } else {
        return false;
      }
    }
    ```

    This method would ensure that whenever you do `store.findRecord('ticket',
    id)` you will always get a ticket that is no more than 20 minutes old. In
    case the cached version is more than 20 minutes old, `findRecord` will not
    resolve until you fetched the latest version.

    By default this hook returns `false`, as most UIs should not block user
    interactions while waiting on data update.

    Note that, with default settings, `shouldBackgroundReloadRecord` will always
    re-fetch the records in the background even if `shouldReloadRecord` returns
    `false`. You can override `shouldBackgroundReloadRecord` if this does not
    suit your use case.
  since: 1.13.0
  itemtype: method
  name: shouldReloadRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: ''
    type: Boolean
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 535
  description: |-
    This method is used by the store to determine if the store should
    reload all records from the adapter when records are requested by
    `store.findAll`.

    If this method returns `true`, the store will re-fetch all records from
    the adapter. If this method returns `false`, the store will resolve
    immediately using the cached records.

    For example, if you are building an events ticketing system, in which users
    can only reserve tickets for 20 minutes at a time, and want to ensure that
    in each route you have data that is no more than 20 minutes old you could
    write:

    ```javascript
    shouldReloadAll(store, snapshotArray) {
      let snapshots = snapshotArray.snapshots();

      return snapshots.any((ticketSnapshot) => {
        let lastAccessedAt = ticketSnapshot.attr('lastAccessedAt');
        let timeDiff = moment().diff(lastAccessedAt, 'minutes');

        if (timeDiff > 20) {
          return true;
        } else {
          return false;
        }
      });
    }
    ```

    This method would ensure that whenever you do `store.findAll('ticket')` you
    will always get a list of tickets that are no more than 20 minutes old. In
    case a cached version is more than 20 minutes old, `findAll` will not
    resolve until you fetched the latest versions.

    By default this methods returns `true` if the passed `snapshotRecordArray`
    is empty (meaning that there are no records locally available yet),
    otherwise it returns `false`.

    Note that, with default settings, `shouldBackgroundReloadAll` will always
    re-fetch all the records in the background even if `shouldReloadAll` returns
    `false`. You can override `shouldBackgroundReloadAll` if this does not suit
    your use case.
  since: 1.13.0
  itemtype: method
  name: shouldReloadAll
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: snapshotRecordArray
    description: ''
    type: DS.SnapshotRecordArray
  return:
    description: ''
    type: Boolean
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 590
  description: |-
    This method is used by the store to determine if the store should
    reload a record after the `store.findRecord` method resolves a
    cached record.

    This method is *only* checked by the store when the store is
    returning a cached record.

    If this method returns `true` the store will re-fetch a record from
    the adapter.

    For example, if you do not want to fetch complex data over a mobile
    connection, or if the network is down, you can implement
    `shouldBackgroundReloadRecord` as follows:

    ```javascript
    shouldBackgroundReloadRecord(store, snapshot) {
      let connection = window.navigator.connection;

      if (connection === 'cellular' || connection === 'none') {
        return false;
      } else {
        return true;
      }
    }
    ```

    By default this hook returns `true` so the data for the record is updated
    in the background.
  since: 1.13.0
  itemtype: method
  name: shouldBackgroundReloadRecord
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: snapshot
    description: ''
    type: DS.Snapshot
  return:
    description: ''
    type: Boolean
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/adapter.js
  line: 630
  description: |-
    This method is used by the store to determine if the store should
    reload a record array after the `store.findAll` method resolves
    with a cached record array.

    This method is *only* checked by the store when the store is
    returning a cached record array.

    If this method returns `true` the store will re-fetch all records
    from the adapter.

    For example, if you do not want to fetch complex data over a mobile
    connection, or if the network is down, you can implement
    `shouldBackgroundReloadAll` as follows:

    ```javascript
    shouldBackgroundReloadAll(store, snapshotArray) {
      let connection = window.navigator.connection;

      if (connection === 'cellular' || connection === 'none') {
        return false;
      } else {
        return true;
      }
    }
    ```

    By default this method returns `true`, indicating that a background reload
    should always be triggered.
  since: 1.13.0
  itemtype: method
  name: shouldBackgroundReloadAll
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: snapshotRecordArray
    description: ''
    type: DS.SnapshotRecordArray
  return:
    description: ''
    type: Boolean
  class: DS.Adapter
  module: ember-data
  namespace: DS
- file: addon/attr.js
  line: 38
  description: |-
    `DS.attr` defines an attribute on a [DS.Model](/api/data/classes/DS.Model.html).
    By default, attributes are passed through as-is, however you can specify an
    optional type to have the value automatically transformed.
    Ember Data ships with four basic transform types: `string`, `number`,
    `boolean` and `date`. You can define your own transforms by subclassing
    [DS.Transform](/api/data/classes/DS.Transform.html).

    Note that you cannot use `attr` to define an attribute of `id`.

    `DS.attr` takes an optional hash as a second parameter, currently
    supported options are:

    - `defaultValue`: Pass a string or a function to be called to set the attribute
                      to a default value if none is supplied.

    Example

    ```app/models/user.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      username: DS.attr('string'),
      email: DS.attr('string'),
      verified: DS.attr('boolean', { defaultValue: false })
    });
    ```

    Default value can also be a function. This is useful it you want to return
    a new object for each attribute.

    ```app/models/user.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      username: DS.attr('string'),
      email: DS.attr('string'),
      settings: DS.attr({
        defaultValue() {
          return {};
        }
      })
    });
    ```

    The `options` hash is passed as second argument to a transforms'
    `serialize` and `deserialize` method. This allows to configure a
    transformation and adapt the corresponding value, based on the config:

    ```app/models/post.js
    import DS from 'ember-data';

    export default DS.Model.extend({
      text: DS.attr('text', {
        uppercase: true
      })
    });
    ```

    ```app/transforms/text.js
    import DS from 'ember-data';

    export default DS.Transform.extend({
      serialize(value, options) {
        if (options.uppercase) {
          return value.toUpperCase();
        }

        return value;
      },

      deserialize(value) {
        return value;
      }
    })
    ```
  itemtype: method
  name: attr
  params:
  - name: type
    description: the attribute type
    type: String|Object
  - name: options
    description: a hash of options
    type: Object
  return:
    description: ''
    type: Attribute
  class: DS
  module: ember-data
- file: addon/serializer.js
  line: 29
  description: |-
    The `store` property is the application's `store` that contains
    all records. It can be used to look up serializers for other model
    types that may be nested inside the payload response.

    Example:

    ```js
    Serializer.extend({
      extractRelationship(relationshipModelName, relationshipHash) {
        var modelClass = this.store.modelFor(relationshipModelName);
        var relationshipSerializer = this.store.serializerFor(relationshipModelName);
        return relationshipSerializer.normalize(modelClass, relationshipHash);
      }
    });
    ```
  itemtype: property
  name: store
  type: "{DS.Store}"
  access: public
  tagname: ''
  class: DS.Serializer
  module: ember-data
  namespace: DS
- file: addon/serializer.js
  line: 51
  description: |-
    The `normalizeResponse` method is used to normalize a payload from the
    server to a JSON-API Document.

    http://jsonapi.org/format/#document-structure

    Example:

    ```js
    Serializer.extend({
      normalizeResponse(store, primaryModelClass, payload, id, requestType) {
        if (requestType === 'findRecord') {
          return this.normalize(primaryModelClass, payload);
        } else {
          return payload.reduce(function(documentHash, item) {
            let { data, included } = this.normalize(primaryModelClass, item);
            documentHash.included.push(...included);
            documentHash.data.push(data);
            return documentHash;
          }, { data: [], included: [] })
        }
      }
    });
    ```
  since: 1.13.0
  itemtype: method
  name: normalizeResponse
  params:
  - name: store
    description: ''
    type: DS.Store
  - name: primaryModelClass
    description: ''
    type: DS.Model
  - name: payload
    description: ''
    type: Object
  - name: id
    description: ''
    type: String|Number
  - name: requestType
    description: ''
    type: String
  return:
    description: JSON-API Document
    type: Object
  class: DS.Serializer
  module: ember-data
  namespace: DS
- file: addon/serializer.js
  line: 87
  description: |-
    The `serialize` method is used when a record is saved in order to convert
    the record into the form that your external data source expects.

    `serialize` takes an optional `options` hash with a single option:

    - `includeId`: If this is `true`, `serialize` should include the ID
      in the serialized object it builds.

    Example:

    ```js
    Serializer.extend({
      serialize(snapshot, options) {
        var json = {
          id: snapshot.id
        };

        snapshot.eachAttribute((key, attribute) => {
          json[key] = snapshot.attr(key);
        });

        snapshot.eachRelationship((key, relationship) => {
          if (relationship.kind === 'belongsTo') {
            json[key] = snapshot.belongsTo(key, { id: true });
          } else if (relationship.kind === 'hasMany') {
            json[key] = snapshot.hasMany(key, { ids: true });
          }
        });

        return json;
      },
    });
    ```
  itemtype: method
  name: serialize
  params:
  - name: snapshot
    description: ''
    type: DS.Snapshot
  - name: options
    description: ''
    type: Object
    optional: true
  return:
    description: ''
    type: Object
  class: DS.Serializer
  module: ember-data
  namespace: DS
- file: addon/serializer.js
  line: 129
  description: |-
    The `normalize` method is used to convert a payload received from your
    external data source into the normalized form `store.push()` expects. You
    should override this method, munge the hash and return the normalized
    payload.

    Example:

    ```js
    Serializer.extend({
      normalize(modelClass, resourceHash) {
        var data = {
          id:            resourceHash.id,
          type:          modelClass.modelName,
          attributes:    resourceHash
        };
        return { data: data };
      }
    })
    ```
  itemtype: method
  name: normalize
  params:
  - name: typeClass
    description: ''
    type: DS.Model
  - name: hash
    description: ''
    type: Object
  return:
    description: ''
    type: Object
  class: DS.Serializer
  module: ember-data
  namespace: DS
- file: addon/transform.js
  line: 71
  description: |-
    When given a deserialized value from a record attribute this
    method must return the serialized value.

    Example

    ```javascript
    serialize(deserialized, options) {
      return Ember.isEmpty(deserialized) ? null : Number(deserialized);
    }
    ```
  itemtype: method
  name: serialize
  params:
  - name: deserialized
    description: The deserialized value
  - name: options
    description: hash of options passed to `DS.attr`
  return:
    description: The serialized value
  class: DS.Transform
  module: ember-data
  namespace: DS
- file: addon/transform.js
  line: 90
  description: |-
    When given a serialize value from a JSON object this method must
    return the deserialized value for the record attribute.

    Example

    ```javascript
    deserialize(serialized, options) {
      return empty(serialized) ? null : Number(serialized);
    }
    ```
  itemtype: method
  name: deserialize
  params:
  - name: serialized
    description: The serialized value
  - name: options
    description: hash of options passed to `DS.attr`
  return:
    description: The deserialized value
  class: DS.Transform
  module: ember-data
  namespace: DS
- file: node_modules/ember-inflector/addon/lib/ext/string.js
  line: 8
  description: See {{#crossLink "Ember.String/pluralize"}}{{/crossLink}}
  itemtype: method
  name: pluralize
  class: DS.String
  module: ember-data
- file: node_modules/ember-inflector/addon/lib/ext/string.js
  line: 18
  description: See {{#crossLink "Ember.String/singularize"}}{{/crossLink}}
  itemtype: method
  name: singularize
  class: DS.String
  module: ember-data
  namespace: DS
- file: node_modules/ember-inflector/addon/lib/helpers/pluralize.js
  line: 4
  description: |-
    If you have Ember Inflector (such as if Ember Data is present),
     pluralize a word. For example, turn "ox" into "oxen".
    Example:
    {{pluralize count myProperty}}
     {{pluralize 1 "oxen"}}
     {{pluralize myProperty}}
     {{pluralize "ox"}}
  itemtype: method
  name: pluralize
  params:
  - name: count
    description: count of objects
    type: Number|Property
    optional: true
  - name: word
    description: word to pluralize
    type: String|Property
  class: DS.Ember.HTMLBars.helpers
  module: ember-data
- file: node_modules/ember-inflector/addon/lib/helpers/singularize.js
  line: 4
  description: |-
    If you have Ember Inflector (such as if Ember Data is present),
     singularize a word. For example, turn "oxen" into "ox".
    Example:
    {{singularize myProperty}}
     {{singularize "oxen"}}
  itemtype: method
  name: singularize
  params:
  - name: word
    description: word to singularize
    type: String|Property
  class: Ember.HTMLBars.helpers
  module: ember-data
- file: node_modules/ember-inflector/addon/lib/system/inflector.js
  line: 125
  access: public
  tagname: |-
    As inflections can be costly, and commonly the same subset of words are repeatedly
    inflected an optional cache is provided.
  itemtype: method
  name: enableCache
  class: Ember.Inflector
  module: ember-data
  namespace: Ember
- file: node_modules/ember-inflector/addon/lib/system/inflector.js
  line: 147
  access: public
  tagname: ''
  itemtype: method
  name: purgedCache
  class: Ember.Inflector
  module: ember-data
  namespace: Ember
- file: node_modules/ember-inflector/addon/lib/system/inflector.js
  line: 158
  access: public
  tagname: disable caching
  itemtype: method
  name: disableCache;
  class: Ember.Inflector
  module: ember-data
  namespace: Ember
- file: node_modules/ember-inflector/addon/lib/system/inflector.js
  line: 176
  itemtype: method
  name: plural
  params:
  - name: regex
    description: ''
    type: RegExp
  - name: string
    description: ''
    type: String
  class: Ember.Inflector
  module: ember-data
  namespace: Ember
- file: node_modules/ember-inflector/addon/lib/system/inflector.js
  line: 186
  itemtype: method
  name: singular
  params:
  - name: regex
    description: ''
    type: RegExp
  - name: string
    description: ''
    type: String
  class: Ember.Inflector
  module: ember-data
  namespace: Ember
- file: node_modules/ember-inflector/addon/lib/system/inflector.js
  line: 196
  itemtype: method
  name: uncountable
  params:
  - name: regex
    description: ''
    type: String
  class: Ember.Inflector
  module: ember-data
  namespace: Ember
- file: node_modules/ember-inflector/addon/lib/system/inflector.js
  line: 205
  itemtype: method
  name: irregular
  params:
  - name: singular
    description: ''
    type: String
  - name: plural
    description: ''
    type: String
  class: Ember.Inflector
  module: ember-data
  namespace: Ember
- file: node_modules/ember-inflector/addon/lib/system/inflector.js
  line: 215
  itemtype: method
  name: pluralize
  params:
  - name: word
    description: ''
    type: String
  class: Ember.Inflector
  module: ember-data
  namespace: Ember
- file: node_modules/ember-inflector/addon/lib/system/inflector.js
  line: 226
  itemtype: method
  name: singularize
  params:
  - name: word
    description: ''
    type: String
  class: Ember.Inflector
  module: ember-data
  namespace: Ember
- file: node_modules/ember-inflector/addon/lib/system/inflector.js
  line: 238
  access: protected
  tagname: ''
  itemtype: method
  name: inflect
  params:
  - name: word
    description: ''
    type: String
  - name: typeRules
    description: ''
    type: Object
  - name: irregular
    description: ''
    type: Object
  class: Ember.Inflector
  module: ember-data
  namespace: Ember
warnings:
- message: 'param name missing: {Promise|Object}'
  line: " addon/-private/system/references/record.js:62"
- message: 'replacing incorrect tag: returns with return'
  line: " addon/-private/system/identity-map.js:16"
- message: 'replacing incorrect tag: returns with return'
  line: " addon/-private/system/internal-model-map.js:33"
- message: |-
    Missing item type
    Computes the set of internal models reachable from `this` across exactly one
    relationship.
  line: " addon/-private/system/model/internal-model.js:410"
- message: |-
    Missing item type
    Computes the set of internal models reachable from this internal model.

    Reachability is determined over the relationship graph (ie a graph where
    nodes are internal models and edges are belongs to or has many
    relationships).
  line: " addon/-private/system/model/internal-model.js:432"
- message: |-
    Missing item type
    Unload the record for this internal model. This will cause the record to be
    destroyed and freed up for garbage collection. It will also do a check
    for cleaning up internal models.

    This check is performed by first computing the set of related internal
    models. If all records in this set are unloaded, then the entire set is
    destroyed. Otherwise, nothing in the set is destroyed.

    This means that this internal model will be freed up for garbage collection
    once all models that refer to it via some relationship are also unloaded.
  line: " addon/-private/system/model/internal-model.js:465"
- message: |-
    Missing item type
    A "map" of records based on their ID for this modelName
  line: " addon/-private/system/internal-model-map.js:22"
- message: Missing item type
  line: " addon/-private/system/internal-model-map.js:33"
- message: |-
    Missing item type
    An array of all models of this modelName
  line: " addon/-private/system/internal-model-map.js:86"
- message: |-
    Missing item type
    meta information about internalModels
  line: " addon/-private/system/internal-model-map.js:93"
- message: |-
    Missing item type
    deprecated (and unsupported) way of accessing modelClass
  line: " addon/-private/system/internal-model-map.js:100"
